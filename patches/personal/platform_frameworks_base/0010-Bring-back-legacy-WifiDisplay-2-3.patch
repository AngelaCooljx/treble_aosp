From 580d3df4436206d89a89c7ba3bf80669237757ef Mon Sep 17 00:00:00 2001
From: Indranil Chakraborty <ichakrab@codeaurora.org>
Date: Fri, 23 Mar 2018 21:53:55 +0530
Subject: [PATCH 10/10] Bring back legacy WifiDisplay (2/3)

Squash of:
- Merge changes for launching wifidisplay from system settings
- WifiDisplayController: handle preexisting p2p connection status
- SystemUI: Check whether the selected WFD route is available
---
 .../app/MediaRouteDialogPresenter.java        |   3 +-
 .../statusbar/policy/CastControllerImpl.java  |   3 +-
 .../display/ExtendedRemoteDisplayHelper.java  | 152 ++++++++++++++
 .../server/display/WifiDisplayController.java | 193 +++++++++++++-----
 4 files changed, 294 insertions(+), 57 deletions(-)
 create mode 100644 services/core/java/com/android/server/display/ExtendedRemoteDisplayHelper.java

diff --git a/core/java/com/android/internal/app/MediaRouteDialogPresenter.java b/core/java/com/android/internal/app/MediaRouteDialogPresenter.java
index 5628b7ed9d15..b71d7ae90390 100644
--- a/core/java/com/android/internal/app/MediaRouteDialogPresenter.java
+++ b/core/java/com/android/internal/app/MediaRouteDialogPresenter.java
@@ -89,7 +89,8 @@ public abstract class MediaRouteDialogPresenter {
         final MediaRouter router = context.getSystemService(MediaRouter.class);
 
         MediaRouter.RouteInfo route = router.getSelectedRoute();
-        if (route.isDefault() || !route.matchesTypes(routeTypes)) {
+        if (route.isDefault() || !route.matchesTypes(routeTypes)
+            || route.getStatusCode() == MediaRouter.RouteInfo.STATUS_NOT_AVAILABLE) {
             final MediaRouteChooserDialog d = new MediaRouteChooserDialog(context, theme,
                     showProgressBarWhenEmpty);
             d.setRouteTypes(routeTypes);
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/CastControllerImpl.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/CastControllerImpl.java
index f7b601b9d284..060f55c87b33 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/CastControllerImpl.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/CastControllerImpl.java
@@ -167,7 +167,8 @@ public class CastControllerImpl implements CastController {
                 int statusCode = route.getStatusCode();
                 if (statusCode == RouteInfo.STATUS_CONNECTING) {
                     device.state = CastDevice.STATE_CONNECTING;
-                } else if (route.isSelected() || statusCode == RouteInfo.STATUS_CONNECTED) {
+                } else if (route.isSelected() && statusCode != RouteInfo.STATUS_NOT_AVAILABLE
+                        || statusCode == RouteInfo.STATUS_CONNECTED) {
                     device.state = CastDevice.STATE_CONNECTED;
                 } else {
                     device.state = CastDevice.STATE_DISCONNECTED;
diff --git a/services/core/java/com/android/server/display/ExtendedRemoteDisplayHelper.java b/services/core/java/com/android/server/display/ExtendedRemoteDisplayHelper.java
new file mode 100644
index 000000000000..d6306a3175a1
--- /dev/null
+++ b/services/core/java/com/android/server/display/ExtendedRemoteDisplayHelper.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.android.server.display;
+
+import android.content.Context;
+import android.media.RemoteDisplay;
+import android.os.Handler;
+import android.util.Slog;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+class ExtendedRemoteDisplayHelper {
+    private static final String TAG = "ExtendedRemoteDisplayHelper";
+    private static final boolean DEBUG = false;
+
+    // ExtendedRemoteDisplay class
+    // ExtendedRemoteDisplay is an enhanced RemoteDisplay.
+    // It has similar interface as RemoteDisplay class.
+    private static Class sExtRemoteDisplayClass;
+
+    // Method object for the API ExtendedRemoteDisplay.Listen
+    // ExtendedRemoteDisplay.Listen has the same API signature as RemoteDisplay.Listen
+    // except for an additional argument to pass the Context.
+    private static Method sExtRemoteDisplayListen;
+
+    // Method Object for the API ExtendedRemoteDisplay.Dispose
+    // ExtendedRemoteDisplay.Dispose follows the same API signature as RemoteDisplay.Dispose.
+    private static Method sExtRemoteDisplayDispose;
+
+    static {
+        // Check availability of ExtendedRemoteDisplay runtime
+        try {
+            sExtRemoteDisplayClass = Class.forName("com.qualcomm.wfd.ExtendedRemoteDisplay");
+        } catch (Throwable t) {
+            Slog.i(TAG, "ExtendedRemoteDisplay: not available");
+        }
+
+        if (sExtRemoteDisplayClass != null) {
+            // If ExtendedRemoteDisplay is available find the methods
+            Slog.i(TAG, "ExtendedRemoteDisplay: is available, finding methods");
+            try {
+                Class args[] = { String.class, RemoteDisplay.Listener.class,
+                        Handler.class, Context.class };
+                sExtRemoteDisplayListen =
+                        sExtRemoteDisplayClass.getDeclaredMethod("listen", args);
+            } catch (Throwable t) {
+                Slog.i(TAG, "ExtendedRemoteDisplay.listen: not available");
+            }
+
+            try {
+                Class args[] = {};
+                sExtRemoteDisplayDispose =
+                        sExtRemoteDisplayClass.getDeclaredMethod("dispose", args);
+            } catch (Throwable t) {
+                Slog.i(TAG, "ExtendedRemoteDisplay.dispose: not available");
+            }
+        }
+    }
+
+    /**
+     * Starts listening for displays to be connected on the specified interface.
+     *
+     * @param iface The interface address and port in the form "x.x.x.x:y".
+     * @param listener The listener to invoke when displays are connected or disconnected.
+     * @param handler The handler on which to invoke the listener.
+     * @param context The current service context.
+     *  */
+    public static Object listen(String iface, RemoteDisplay.Listener listener,
+            Handler handler, Context context) {
+        Object extRemoteDisplay = null;
+        if (DEBUG) Slog.i(TAG, "ExtendedRemoteDisplay.listen");
+
+        if (sExtRemoteDisplayListen != null && sExtRemoteDisplayDispose != null) {
+            try {
+                extRemoteDisplay = sExtRemoteDisplayListen.invoke(null,
+                        iface, listener, handler, context);
+            } catch (InvocationTargetException e) {
+                Slog.e(TAG, "ExtendedRemoteDisplay.listen: InvocationTargetException");
+                Throwable cause = e.getCause();
+                if (cause instanceof RuntimeException) {
+                    throw (RuntimeException) cause;
+                } else if (cause instanceof Error) {
+                    throw (Error) cause;
+                } else {
+                    throw new RuntimeException(e);
+                }
+            } catch (IllegalAccessException e) {
+                Slog.e(TAG, "ExtendedRemoteDisplay.listen: IllegalAccessException", e);
+            }
+        }
+        return extRemoteDisplay;
+    }
+
+    /**
+     * Disconnects the remote display and stops listening for new connections.
+     */
+    public static void dispose(Object extRemoteDisplay) {
+        if (DEBUG) Slog.i(TAG, "ExtendedRemoteDisplay.dispose");
+        try {
+            sExtRemoteDisplayDispose.invoke(extRemoteDisplay);
+        } catch (InvocationTargetException e) {
+            Slog.e(TAG, "ExtendedRemoteDisplay.dispose: InvocationTargetException");
+            Throwable cause = e.getCause();
+            if (cause instanceof RuntimeException) {
+                throw (RuntimeException) cause;
+            } else if (cause instanceof Error) {
+                throw (Error) cause;
+            } else {
+                throw new RuntimeException(e);
+            }
+        } catch (IllegalAccessException e) {
+            Slog.e(TAG, "ExtendedRemoteDisplay.dispose: IllegalAccessException", e);
+        }
+    }
+
+    /**
+     * Checks if ExtendedRemoteDisplay is available
+     */
+    public static boolean isAvailable() {
+        return (sExtRemoteDisplayClass != null && sExtRemoteDisplayDispose != null &&
+                sExtRemoteDisplayListen != null);
+    }
+}
diff --git a/services/core/java/com/android/server/display/WifiDisplayController.java b/services/core/java/com/android/server/display/WifiDisplayController.java
index cd36dd02a8c6..ad0e9018f266 100644
--- a/services/core/java/com/android/server/display/WifiDisplayController.java
+++ b/services/core/java/com/android/server/display/WifiDisplayController.java
@@ -136,6 +136,10 @@ final class WifiDisplayController implements DumpUtils.Dump {
     // Number of connection retries remaining.
     private int mConnectionRetriesLeft;
 
+    // The Extended remote display that is listening on the connection.
+    // Created after the Wifi P2P network is connected.
+    private Object mExtRemoteDisplay;
+
     // The remote display that is listening on the connection.
     // Created after the Wifi P2P network is connected.
     private RemoteDisplay mRemoteDisplay;
@@ -367,7 +371,8 @@ final class WifiDisplayController implements DumpUtils.Dump {
     }
 
     private void updateScanState() {
-        if (mScanRequested && mWfdEnabled && mDesiredDevice == null) {
+        if (mScanRequested && mWfdEnabled && mDesiredDevice == null &&
+                mConnectedDevice == null && mDisconnectingDevice == null) {
             if (!mDiscoverPeersInProgress) {
                 Slog.i(TAG, "Starting Wifi display scan.");
                 mDiscoverPeersInProgress = true;
@@ -543,6 +548,10 @@ final class WifiDisplayController implements DumpUtils.Dump {
             return;
         }
 
+        if (handlePreExistingConnection(device)) {
+            Slog.i(TAG, "Already handle the preexisting P2P connection status");
+            return;
+        }
         mDesiredDevice = device;
         mConnectionRetriesLeft = CONNECT_MAX_RETRIES;
         updateConnection();
@@ -573,14 +582,21 @@ final class WifiDisplayController implements DumpUtils.Dump {
 
         // Step 1. Before we try to connect to a new device, tell the system we
         // have disconnected from the old one.
-        if (mRemoteDisplay != null && mConnectedDevice != mDesiredDevice) {
-            Slog.i(TAG, "Stopped listening for RTSP connection on " + mRemoteDisplayInterface
-                    + " from Wifi display: " + mConnectedDevice.deviceName);
+        if ((mRemoteDisplay != null || mExtRemoteDisplay != null) &&
+                mConnectedDevice != mDesiredDevice ||
+                (mRemoteDisplayInterface != null && mConnectedDevice == null)) {
+            Slog.i(TAG, "Stopped listening for RTSP connection on "
+                    + mRemoteDisplayInterface);
+
+            if (mRemoteDisplay != null) {
+                mRemoteDisplay.dispose();
+            } else if (mExtRemoteDisplay != null) {
+                ExtendedRemoteDisplayHelper.dispose(mExtRemoteDisplay);
+            }
 
-            mRemoteDisplay.dispose();
+            mExtRemoteDisplay = null;
             mRemoteDisplay = null;
             mRemoteDisplayInterface = null;
-            mRemoteDisplayConnected = false;
             mHandler.removeCallbacks(mRtspTimeout);
 
             mWifiP2pManager.setMiracastMode(WifiP2pManager.MIRACAST_DISABLED);
@@ -590,7 +606,7 @@ final class WifiDisplayController implements DumpUtils.Dump {
         }
 
         // Step 2. Before we try to connect to a new device, disconnect from the old one.
-        if (mDisconnectingDevice != null) {
+        if (mRemoteDisplayConnected || mDisconnectingDevice != null) {
             return; // wait for asynchronous callback
         }
         if (mConnectedDevice != null && mConnectedDevice != mDesiredDevice) {
@@ -674,6 +690,51 @@ final class WifiDisplayController implements DumpUtils.Dump {
             return; // done
         }
 
+        //Before we connect, we need to set the oldDevice to the desiredDevice to check
+        //the device on receiving callbacks from the Remote display modules
+        final WifiP2pDevice oldDevice = mDesiredDevice;
+        RemoteDisplay.Listener listener = new RemoteDisplay.Listener() {
+            @Override
+            public void onDisplayConnected(Surface surface,
+                     int width, int height, int flags, int session) {
+                if (mConnectedDevice == oldDevice && !mRemoteDisplayConnected) {
+                    Slog.i(TAG, "Opened RTSP connection with Wifi display: "
+                            + mConnectedDevice.deviceName);
+                    mRemoteDisplayConnected = true;
+                    mHandler.removeCallbacks(mRtspTimeout);
+
+                    if (mWifiDisplayCertMode) {
+                        mListener.onDisplaySessionInfo(
+                        getSessionInfo(mConnectedDeviceGroupInfo, session));
+                    }
+
+                    final WifiDisplay display = createWifiDisplay(mConnectedDevice);
+                    advertiseDisplay(display, surface, width, height, flags);
+                }
+            }
+
+            @Override
+            public void onDisplayDisconnected() {
+                if (mConnectedDevice == oldDevice) {
+                    Slog.i(TAG, "Closed RTSP connection with Wifi display: "
+                            + mConnectedDevice.deviceName);
+                    mHandler.removeCallbacks(mRtspTimeout);
+                    mRemoteDisplayConnected = false;
+                    disconnect();
+                }
+            }
+
+            @Override
+            public void onDisplayError(int error) {
+                if (mConnectedDevice == oldDevice) {
+                    Slog.i(TAG, "Lost RTSP connection with Wifi display due to error "
+                            + error + ": " + mConnectedDevice.deviceName);
+                    mHandler.removeCallbacks(mRtspTimeout);
+                    handleConnectionFailure(false);
+                }
+            }
+        };
+
         // Step 5. Try to connect.
         if (mConnectedDevice == null && mConnectingDevice == null) {
             Slog.i(TAG, "Connecting to Wifi display: " + mDesiredDevice.deviceName);
@@ -699,6 +760,18 @@ final class WifiDisplayController implements DumpUtils.Dump {
             WifiDisplay display = createWifiDisplay(mConnectingDevice);
             advertiseDisplay(display, null, 0, 0, 0);
 
+            if (ExtendedRemoteDisplayHelper.isAvailable() && mExtRemoteDisplay == null) {
+               final int port = getPortNumber(mDesiredDevice);
+               //IP is superfluous for WFD source, and we don't have one at this stage anyway since
+               //P2P connection hasn't been established yet
+               final String iface = "255.255.255.255:" + port;
+               mRemoteDisplayInterface = iface;
+               Slog.i(TAG, "Listening for RTSP connection on " + iface
+                       + " from Wifi display: " + mDesiredDevice.deviceName);
+               mExtRemoteDisplay = ExtendedRemoteDisplayHelper.listen(iface,
+                       listener, mHandler, mContext);
+            }
+
             final WifiP2pDevice newDevice = mDesiredDevice;
             mWifiP2pManager.connect(mWifiP2pChannel, config, new ActionListener() {
                 @Override
@@ -736,54 +809,16 @@ final class WifiDisplayController implements DumpUtils.Dump {
 
             mWifiP2pManager.setMiracastMode(WifiP2pManager.MIRACAST_SOURCE);
 
-            final WifiP2pDevice oldDevice = mConnectedDevice;
             final int port = getPortNumber(mConnectedDevice);
             final String iface = addr.getHostAddress() + ":" + port;
             mRemoteDisplayInterface = iface;
 
-            Slog.i(TAG, "Listening for RTSP connection on " + iface
-                    + " from Wifi display: " + mConnectedDevice.deviceName);
-
-            mRemoteDisplay = RemoteDisplay.listen(iface, new RemoteDisplay.Listener() {
-                @Override
-                public void onDisplayConnected(Surface surface,
-                        int width, int height, int flags, int session) {
-                    if (mConnectedDevice == oldDevice && !mRemoteDisplayConnected) {
-                        Slog.i(TAG, "Opened RTSP connection with Wifi display: "
-                                + mConnectedDevice.deviceName);
-                        mRemoteDisplayConnected = true;
-                        mHandler.removeCallbacks(mRtspTimeout);
-
-                        if (mWifiDisplayCertMode) {
-                            mListener.onDisplaySessionInfo(
-                                    getSessionInfo(mConnectedDeviceGroupInfo, session));
-                        }
-
-                        final WifiDisplay display = createWifiDisplay(mConnectedDevice);
-                        advertiseDisplay(display, surface, width, height, flags);
-                    }
-                }
-
-                @Override
-                public void onDisplayDisconnected() {
-                    if (mConnectedDevice == oldDevice) {
-                        Slog.i(TAG, "Closed RTSP connection with Wifi display: "
-                                + mConnectedDevice.deviceName);
-                        mHandler.removeCallbacks(mRtspTimeout);
-                        disconnect();
-                    }
-                }
-
-                @Override
-                public void onDisplayError(int error) {
-                    if (mConnectedDevice == oldDevice) {
-                        Slog.i(TAG, "Lost RTSP connection with Wifi display due to error "
-                                + error + ": " + mConnectedDevice.deviceName);
-                        mHandler.removeCallbacks(mRtspTimeout);
-                        handleConnectionFailure(false);
-                    }
-                }
-            }, mHandler, mContext.getOpPackageName());
+            if (!ExtendedRemoteDisplayHelper.isAvailable()) {
+               Slog.i(TAG, "Listening for RTSP connection on " + iface
+                       + " from Wifi display: " + mConnectedDevice.deviceName);
+               mRemoteDisplay = RemoteDisplay.listen(iface, listener,
+                       mHandler, mContext.getOpPackageName());
+            }
 
             // Use extended timeout value for certification, as some tests require user inputs
             int rtspTimeout = mWifiDisplayCertMode ?
@@ -794,7 +829,7 @@ final class WifiDisplayController implements DumpUtils.Dump {
     }
 
     private WifiDisplaySessionInfo getSessionInfo(WifiP2pGroup info, int session) {
-        if (info == null) {
+        if (info == null || info.getOwner() == null) {
             return null;
         }
         Inet4Address addr = getInterfaceAddress(info);
@@ -835,6 +870,10 @@ final class WifiDisplayController implements DumpUtils.Dump {
                 mWifiP2pManager.requestGroupInfo(mWifiP2pChannel, new GroupInfoListener() {
                     @Override
                     public void onGroupInfoAvailable(WifiP2pGroup info) {
+                        if (info == null) {
+                           return;
+                        }
+
                         if (DEBUG) {
                             Slog.d(TAG, "Received group info: " + describeWifiP2pGroup(info));
                         }
@@ -854,8 +893,9 @@ final class WifiDisplayController implements DumpUtils.Dump {
                         }
 
                         if (mWifiDisplayCertMode) {
-                            boolean owner = info.getOwner().deviceAddress
-                                    .equals(mThisDevice.deviceAddress);
+                            boolean owner = info.getOwner() != null ?
+                                    info.getOwner().deviceAddress.equals(
+                                            mThisDevice.deviceAddress) : false;
                             if (owner && info.getClientList().isEmpty()) {
                                 // this is the case when we started Autonomous GO,
                                 // and no client has connected, save group info
@@ -893,6 +933,12 @@ final class WifiDisplayController implements DumpUtils.Dump {
                 disconnect();
             }
 
+            if (mDesiredDevice != null) {
+                Slog.i(TAG, "Reconnect new device: " + mDesiredDevice.deviceName);
+                updateConnection();
+                return;
+            }
+
             // After disconnection for a group, for some reason we have a tendency
             // to get a peer change notification with an empty list of peers.
             // Perform a fresh scan.
@@ -925,7 +971,8 @@ final class WifiDisplayController implements DumpUtils.Dump {
         @Override
         public void run() {
             if (mConnectedDevice != null
-                    && mRemoteDisplay != null && !mRemoteDisplayConnected) {
+                    && (mRemoteDisplay != null || mExtRemoteDisplay != null)
+                    && !mRemoteDisplayConnected) {
                 Slog.i(TAG, "Timed out waiting for Wifi display RTSP connection after "
                         + RTSP_TIMEOUT_SECONDS + " seconds: "
                         + mConnectedDevice.deviceName);
@@ -1009,6 +1056,42 @@ final class WifiDisplayController implements DumpUtils.Dump {
                 mAdvertisedDisplayFlags);
     }
 
+    private boolean handlePreExistingConnection(final WifiP2pDevice device) {
+        if (mNetworkInfo == null || !mNetworkInfo.isConnected() || mWifiDisplayCertMode) {
+            return false;
+        }
+        if (DEBUG) Slog.i(TAG, "Handle the preexisting P2P connection status");
+        mWifiP2pManager.requestGroupInfo(mWifiP2pChannel, new GroupInfoListener() {
+            @Override
+            public void onGroupInfoAvailable(WifiP2pGroup info) {
+                if (info == null) {
+                    return;
+                }
+                if (contains(info, device)) {
+                    if (DEBUG) Slog.i(TAG, "Already connected to the desired device: "
+                            + device.deviceName);
+                    updateConnection();
+                    handleConnectionChanged(mNetworkInfo);
+                } else {
+                    mWifiP2pManager.removeGroup(mWifiP2pChannel, new ActionListener() {
+                        @Override
+                        public void onSuccess() {
+                            Slog.i(TAG, "Disconnect the old device");
+                        }
+
+                        @Override
+                        public void onFailure(int reason) {
+                            Slog.w(TAG, "Failed to disconnect the old device: reason=" + reason);
+                        }
+                    });
+                }
+            }
+        });
+        mDesiredDevice = device;
+        mConnectionRetriesLeft = CONNECT_MAX_RETRIES;
+        return true;
+    }
+
     private static Inet4Address getInterfaceAddress(WifiP2pGroup info) {
         NetworkInterface iface;
         try {
-- 
2.34.1

