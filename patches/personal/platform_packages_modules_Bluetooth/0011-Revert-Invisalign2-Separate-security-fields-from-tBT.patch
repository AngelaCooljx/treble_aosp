From 5cbc1d7dfc504db43e1d3d126e9374025f527cb7 Mon Sep 17 00:00:00 2001
From: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date: Thu, 21 Mar 2024 16:11:24 +0200
Subject: [PATCH 11/11] Revert "[Invisalign2] Separate security fields from
 tBTM_SEC_DEV_REC"

This reverts commit 2c92bb2653a77eded8bfdf25914f23b51a377309.
---
 system/stack/btm/btm_ble_addr.cc            |   8 +-
 system/stack/btm/btm_ble_privacy.cc         |   6 +-
 system/stack/btm/btm_ble_sec.cc             | 220 ++++---
 system/stack/btm/btm_dev.cc                 |  56 +-
 system/stack/btm/btm_devctl.cc              |   2 +-
 system/stack/btm/btm_sec.cc                 | 640 ++++++++++----------
 system/stack/btm/security_device_record.h   | 109 ++--
 system/stack/gatt/gatt_api.cc               |   4 +-
 system/stack/smp/smp_act.cc                 |   8 +-
 system/stack/smp/smp_keys.cc                |   4 +-
 system/stack/smp/smp_l2c.cc                 |   2 +-
 system/stack/test/btm/stack_btm_sec_test.cc |  18 +-
 system/stack/test/gatt/gatt_api_test.cc     |   7 +-
 13 files changed, 523 insertions(+), 561 deletions(-)

diff --git a/system/stack/btm/btm_ble_addr.cc b/system/stack/btm/btm_ble_addr.cc
index 8234ecdfc6..f03567466e 100644
--- a/system/stack/btm/btm_ble_addr.cc
+++ b/system/stack/btm/btm_ble_addr.cc
@@ -147,8 +147,8 @@ bool btm_ble_addr_resolvable(const RawAddress& rpa,
   if (!BTM_BLE_IS_RESOLVE_BDA(rpa)) return false;
 
   if ((p_dev_rec->device_type & BT_DEVICE_TYPE_BLE) &&
-      (p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PID)) {
-    if (rpa_matches_irk(rpa, p_dev_rec->sec_rec.ble_keys.irk)) {
+      (p_dev_rec->ble_keys.key_type & BTM_LE_KEY_PID)) {
+    if (rpa_matches_irk(rpa, p_dev_rec->ble_keys.irk)) {
       btm_ble_init_pseudo_addr(p_dev_rec, rpa);
       return true;
     }
@@ -164,11 +164,11 @@ static bool btm_ble_match_random_bda(void* data, void* context) {
   RawAddress* random_bda = static_cast<RawAddress*>(context);
 
   if (!(p_dev_rec->device_type & BT_DEVICE_TYPE_BLE) ||
-      !(p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PID))
+      !(p_dev_rec->ble_keys.key_type & BTM_LE_KEY_PID))
     // Match fails preconditions
     return true;
 
-  if (rpa_matches_irk(*random_bda, p_dev_rec->sec_rec.ble_keys.irk)) {
+  if (rpa_matches_irk(*random_bda, p_dev_rec->ble_keys.irk)) {
     // Matched
     return false;
   }
diff --git a/system/stack/btm/btm_ble_privacy.cc b/system/stack/btm/btm_ble_privacy.cc
index 4c527c8e74..c46af0b9f5 100644
--- a/system/stack/btm/btm_ble_privacy.cc
+++ b/system/stack/btm/btm_ble_privacy.cc
@@ -532,7 +532,7 @@ static void btm_ble_ble_unsupported_resolving_list_load_dev(
   uint8_t* p = param;
 
   UINT8_TO_STREAM(p, BTM_BLE_META_ADD_IRK_ENTRY);
-  ARRAY_TO_STREAM(p, p_dev_rec->sec_rec.ble_keys.irk, OCTET16_LEN);
+  ARRAY_TO_STREAM(p, p_dev_rec->ble_keys.irk, OCTET16_LEN);
   UINT8_TO_STREAM(p, p_dev_rec->ble.identity_address_with_type.type);
   BDADDR_TO_STREAM(p, p_dev_rec->ble.identity_address_with_type.bda);
 
@@ -545,7 +545,7 @@ static void btm_ble_ble_unsupported_resolving_list_load_dev(
 }
 
 static bool is_peer_identity_key_valid(const tBTM_SEC_DEV_REC& dev_rec) {
-  return dev_rec.sec_rec.ble_keys.key_type & BTM_LE_KEY_PID;
+  return dev_rec.ble_keys.key_type & BTM_LE_KEY_PID;
 }
 
 static Octet16 get_local_irk() { return btm_sec_cb.devcb.id_keys.irk; }
@@ -577,7 +577,7 @@ void btm_ble_resolving_list_load_dev(tBTM_SEC_DEV_REC& dev_rec) {
     return;
   }
 
-  const Octet16& peer_irk = dev_rec.sec_rec.ble_keys.irk;
+  const Octet16& peer_irk = dev_rec.ble_keys.irk;
   const Octet16& local_irk = get_local_irk();
 
   if (dev_rec.ble.identity_address_with_type.bda.IsEmpty()) {
diff --git a/system/stack/btm/btm_ble_sec.cc b/system/stack/btm/btm_ble_sec.cc
index 831ba44958..0417736b1e 100644
--- a/system/stack/btm/btm_ble_sec.cc
+++ b/system/stack/btm/btm_ble_sec.cc
@@ -284,7 +284,7 @@ void BTM_BlePasskeyReply(const RawAddress& bd_addr, uint8_t res,
                                     bt_transport_text(BT_TRANSPORT_LE).c_str(),
                                     smp_status_text(res_smp).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
   SMP_PasskeyReply(bd_addr, res_smp, passkey);
 }
 
@@ -316,7 +316,7 @@ void BTM_BleConfirmReply(const RawAddress& bd_addr, uint8_t res) {
                      bt_transport_text(BT_TRANSPORT_LE).c_str(),
                      smp_status_text(res_smp).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
   SMP_ConfirmReply(bd_addr, res_smp);
 }
 
@@ -349,7 +349,7 @@ void BTM_BleOobDataReply(const RawAddress& bd_addr, uint8_t res, uint8_t len,
                                     bt_transport_text(BT_TRANSPORT_LE).c_str(),
                                     smp_status_text(res_smp).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
   SMP_OobDataReply(bd_addr, res_smp, len, p_data);
 }
 
@@ -379,7 +379,7 @@ void BTM_BleSecureConnectionOobDataReply(const RawAddress& bd_addr,
       base::StringPrintf("transport:%s",
                          bt_transport_text(BT_TRANSPORT_LE).c_str()));
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+  p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
 
   tSMP_SC_OOB_DATA oob;
   memset(&oob, 0, sizeof(tSMP_SC_OOB_DATA));
@@ -807,12 +807,12 @@ static void btm_ble_increment_sign_ctr(const RawAddress& bd_addr,
   p_dev_rec = btm_find_dev(bd_addr);
   if (p_dev_rec != NULL) {
     if (is_local)
-      p_dev_rec->sec_rec.ble_keys.local_counter++;
+      p_dev_rec->ble_keys.local_counter++;
     else
-      p_dev_rec->sec_rec.ble_keys.counter++;
+      p_dev_rec->ble_keys.counter++;
     LOG_VERBOSE("is_local=%d local sign counter=%d peer sign counter=%d",
-                is_local, p_dev_rec->sec_rec.ble_keys.local_counter,
-                p_dev_rec->sec_rec.ble_keys.counter);
+                is_local, p_dev_rec->ble_keys.local_counter,
+                p_dev_rec->ble_keys.counter);
   }
 }
 
@@ -833,7 +833,7 @@ bool btm_ble_get_enc_key_type(const RawAddress& bd_addr, uint8_t* p_key_types) {
 
   p_dev_rec = btm_find_dev(bd_addr);
   if (p_dev_rec != NULL) {
-    *p_key_types = p_dev_rec->sec_rec.ble_keys.key_type;
+    *p_key_types = p_dev_rec->ble_keys.key_type;
     return true;
   }
   return false;
@@ -854,9 +854,9 @@ bool btm_get_local_div(const RawAddress& bd_addr, uint16_t* p_div) {
   *p_div = 0;
   p_dev_rec = btm_find_dev(bd_addr);
 
-  if (p_dev_rec && p_dev_rec->sec_rec.ble_keys.div) {
+  if (p_dev_rec && p_dev_rec->ble_keys.div) {
     status = true;
-    *p_div = p_dev_rec->sec_rec.ble_keys.div;
+    *p_div = p_dev_rec->ble_keys.div;
   }
   LOG_VERBOSE("status=%d (1-OK) DIV=0x%x", status, *p_div);
   return status;
@@ -891,36 +891,34 @@ void btm_sec_save_le_key(const RawAddress& bd_addr, tBTM_LE_KEY_TYPE key_type,
 
     switch (key_type) {
       case BTM_LE_KEY_PENC:
-        p_rec->sec_rec.ble_keys.pltk = p_keys->penc_key.ltk;
-        memcpy(p_rec->sec_rec.ble_keys.rand, p_keys->penc_key.rand,
-               BT_OCTET8_LEN);
-        p_rec->sec_rec.ble_keys.sec_level = p_keys->penc_key.sec_level;
-        p_rec->sec_rec.ble_keys.ediv = p_keys->penc_key.ediv;
-        p_rec->sec_rec.ble_keys.key_size = p_keys->penc_key.key_size;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_PENC;
-        p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
+        p_rec->ble_keys.pltk = p_keys->penc_key.ltk;
+        memcpy(p_rec->ble_keys.rand, p_keys->penc_key.rand, BT_OCTET8_LEN);
+        p_rec->ble_keys.sec_level = p_keys->penc_key.sec_level;
+        p_rec->ble_keys.ediv = p_keys->penc_key.ediv;
+        p_rec->ble_keys.key_size = p_keys->penc_key.key_size;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_PENC;
+        p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
         if (p_keys->penc_key.sec_level == SMP_SEC_AUTHENTICATED)
-          p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
         else
-          p_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
         LOG_VERBOSE(
             "BTM_LE_KEY_PENC key_type=0x%x sec_flags=0x%x sec_leve=0x%x",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.sec_flags,
-            p_rec->sec_rec.ble_keys.sec_level);
+            p_rec->ble_keys.key_type, p_rec->sec_flags,
+            p_rec->ble_keys.sec_level);
         break;
 
       case BTM_LE_KEY_PID:
-        p_rec->sec_rec.ble_keys.irk = p_keys->pid_key.irk;
+        p_rec->ble_keys.irk = p_keys->pid_key.irk;
         p_rec->ble.identity_address_with_type.bda =
             p_keys->pid_key.identity_addr;
         p_rec->ble.identity_address_with_type.type =
             p_keys->pid_key.identity_addr_type;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_PID;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_PID;
         LOG_VERBOSE(
             "BTM_LE_KEY_PID key_type=0x%x save peer IRK, change bd_addr=%s "
             "to id_addr=%s id_addr_type=0x%x",
-            p_rec->sec_rec.ble_keys.key_type,
-            ADDRESS_TO_LOGGABLE_CSTR(p_rec->bd_addr),
+            p_rec->ble_keys.key_type, ADDRESS_TO_LOGGABLE_CSTR(p_rec->bd_addr),
             ADDRESS_TO_LOGGABLE_CSTR(p_keys->pid_key.identity_addr),
             p_keys->pid_key.identity_addr_type);
         /* update device record address as identity address */
@@ -930,56 +928,53 @@ void btm_sec_save_le_key(const RawAddress& bd_addr, tBTM_LE_KEY_TYPE key_type,
         break;
 
       case BTM_LE_KEY_PCSRK:
-        p_rec->sec_rec.ble_keys.pcsrk = p_keys->pcsrk_key.csrk;
-        p_rec->sec_rec.ble_keys.srk_sec_level = p_keys->pcsrk_key.sec_level;
-        p_rec->sec_rec.ble_keys.counter = p_keys->pcsrk_key.counter;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_PCSRK;
-        p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
+        p_rec->ble_keys.pcsrk = p_keys->pcsrk_key.csrk;
+        p_rec->ble_keys.srk_sec_level = p_keys->pcsrk_key.sec_level;
+        p_rec->ble_keys.counter = p_keys->pcsrk_key.counter;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_PCSRK;
+        p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
         if (p_keys->pcsrk_key.sec_level == SMP_SEC_AUTHENTICATED)
-          p_rec->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags |= BTM_SEC_LE_LINK_KEY_AUTHED;
         else
-          p_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
+          p_rec->sec_flags &= ~BTM_SEC_LE_LINK_KEY_AUTHED;
 
         LOG_VERBOSE(
             "BTM_LE_KEY_PCSRK key_type=0x%x sec_flags=0x%x sec_level=0x%x "
             "peer_counter=%d",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.sec_flags,
-            p_rec->sec_rec.ble_keys.srk_sec_level,
-            p_rec->sec_rec.ble_keys.counter);
+            p_rec->ble_keys.key_type, p_rec->sec_flags,
+            p_rec->ble_keys.srk_sec_level, p_rec->ble_keys.counter);
         break;
 
       case BTM_LE_KEY_LENC:
-        p_rec->sec_rec.ble_keys.lltk = p_keys->lenc_key.ltk;
-        p_rec->sec_rec.ble_keys.div = p_keys->lenc_key.div; /* update DIV */
-        p_rec->sec_rec.ble_keys.sec_level = p_keys->lenc_key.sec_level;
-        p_rec->sec_rec.ble_keys.key_size = p_keys->lenc_key.key_size;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_LENC;
+        p_rec->ble_keys.lltk = p_keys->lenc_key.ltk;
+        p_rec->ble_keys.div = p_keys->lenc_key.div; /* update DIV */
+        p_rec->ble_keys.sec_level = p_keys->lenc_key.sec_level;
+        p_rec->ble_keys.key_size = p_keys->lenc_key.key_size;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_LENC;
 
         LOG_VERBOSE(
             "BTM_LE_KEY_LENC key_type=0x%x DIV=0x%x key_size=0x%x "
             "sec_level=0x%x",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.ble_keys.div,
-            p_rec->sec_rec.ble_keys.key_size,
-            p_rec->sec_rec.ble_keys.sec_level);
+            p_rec->ble_keys.key_type, p_rec->ble_keys.div,
+            p_rec->ble_keys.key_size, p_rec->ble_keys.sec_level);
         break;
 
       case BTM_LE_KEY_LCSRK: /* local CSRK has been delivered */
-        p_rec->sec_rec.ble_keys.lcsrk = p_keys->lcsrk_key.csrk;
-        p_rec->sec_rec.ble_keys.div = p_keys->lcsrk_key.div; /* update DIV */
-        p_rec->sec_rec.ble_keys.local_csrk_sec_level =
-            p_keys->lcsrk_key.sec_level;
-        p_rec->sec_rec.ble_keys.local_counter = p_keys->lcsrk_key.counter;
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_LCSRK;
+        p_rec->ble_keys.lcsrk = p_keys->lcsrk_key.csrk;
+        p_rec->ble_keys.div = p_keys->lcsrk_key.div; /* update DIV */
+        p_rec->ble_keys.local_csrk_sec_level = p_keys->lcsrk_key.sec_level;
+        p_rec->ble_keys.local_counter = p_keys->lcsrk_key.counter;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_LCSRK;
         LOG_VERBOSE(
             "BTM_LE_KEY_LCSRK key_type=0x%x DIV=0x%x scrk_sec_level=0x%x "
             "local_counter=%d",
-            p_rec->sec_rec.ble_keys.key_type, p_rec->sec_rec.ble_keys.div,
-            p_rec->sec_rec.ble_keys.local_csrk_sec_level,
-            p_rec->sec_rec.ble_keys.local_counter);
+            p_rec->ble_keys.key_type, p_rec->ble_keys.div,
+            p_rec->ble_keys.local_csrk_sec_level,
+            p_rec->ble_keys.local_counter);
         break;
 
       case BTM_LE_KEY_LID:
-        p_rec->sec_rec.ble_keys.key_type |= BTM_LE_KEY_LID;
+        p_rec->ble_keys.key_type |= BTM_LE_KEY_LID;
         break;
       default:
         LOG_WARN("btm_sec_save_le_key (Bad key_type 0x%02x)", key_type);
@@ -1004,7 +999,7 @@ void btm_sec_save_le_key(const RawAddress& bd_addr, tBTM_LE_KEY_TYPE key_type,
            ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
 
   if (p_rec) {
-    LOG_VERBOSE("sec_flags=0x%x", p_rec->sec_rec.sec_flags);
+    LOG_VERBOSE("sec_flags=0x%x", p_rec->sec_flags);
   }
 }
 
@@ -1026,7 +1021,7 @@ void btm_ble_update_sec_key_size(const RawAddress& bd_addr,
 
   p_rec = btm_find_dev(bd_addr);
   if (p_rec != NULL) {
-    p_rec->sec_rec.enc_key_size = enc_key_size;
+    p_rec->enc_key_size = enc_key_size;
   }
 }
 
@@ -1044,7 +1039,7 @@ uint8_t btm_ble_read_sec_key_size(const RawAddress& bd_addr) {
 
   p_rec = btm_find_dev(bd_addr);
   if (p_rec != NULL) {
-    return p_rec->sec_rec.enc_key_size;
+    return p_rec->enc_key_size;
   } else
     return 0;
 }
@@ -1072,8 +1067,8 @@ void btm_ble_link_sec_check(const RawAddress& bd_addr,
     return;
   }
 
-  if (p_dev_rec->sec_rec.is_security_state_encrypting() ||
-      p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+  if (p_dev_rec->is_security_state_encrypting() ||
+      p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
     /* race condition: discard the security request while central is encrypting
      * the link */
     *p_sec_req_act = BTM_BLE_SEC_REQ_ACT_DISCARD;
@@ -1083,19 +1078,19 @@ void btm_ble_link_sec_check(const RawAddress& bd_addr,
       req_sec_level = SMP_SEC_AUTHENTICATED;
     }
 
-    LOG_VERBOSE("dev_rec sec_flags=0x%x", p_dev_rec->sec_rec.sec_flags);
+    LOG_VERBOSE("dev_rec sec_flags=0x%x", p_dev_rec->sec_flags);
 
     /* currently encrpted  */
-    if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_ENCRYPTED) {
-      if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_AUTHENTICATED)
+    if (p_dev_rec->sec_flags & BTM_SEC_LE_ENCRYPTED) {
+      if (p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED)
         cur_sec_level = SMP_SEC_AUTHENTICATED;
       else
         cur_sec_level = SMP_SEC_UNAUTHENTICATE;
     } else /* unencrypted link */
     {
       /* if bonded, get the key security level */
-      if (p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PENC)
-        cur_sec_level = p_dev_rec->sec_rec.ble_keys.sec_level;
+      if (p_dev_rec->ble_keys.key_type & BTM_LE_KEY_PENC)
+        cur_sec_level = p_dev_rec->ble_keys.sec_level;
       else
         cur_sec_level = SMP_SEC_NONE;
     }
@@ -1143,7 +1138,7 @@ tBTM_STATUS btm_ble_set_encryption(const RawAddress& bd_addr,
   LOG_VERBOSE("sec_act=0x%x role_central=%d", sec_act, p_rec->role_central);
 
   if (sec_act == BTM_BLE_SEC_ENCRYPT_MITM) {
-    p_rec->sec_rec.security_required |= BTM_SEC_IN_MITM;
+    p_rec->security_required |= BTM_SEC_IN_MITM;
   }
 
   switch (sec_act) {
@@ -1177,7 +1172,7 @@ tBTM_STATUS btm_ble_set_encryption(const RawAddress& bd_addr,
 
       if (SMP_Pair(bd_addr) == SMP_STARTED) {
         cmd = BTM_CMD_STARTED;
-        p_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+        p_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
       }
       break;
 
@@ -1232,7 +1227,7 @@ tBTM_STATUS btm_ble_start_encrypt(const RawAddress& bda, bool use_stk,
     return BTM_WRONG_MODE;
   }
 
-  if (p_rec->sec_rec.is_security_state_encrypting()) {
+  if (p_rec->is_security_state_encrypting()) {
     LOG_WARN("Link Encryption is active, Busy!");
     return BTM_BUSY;
   }
@@ -1241,17 +1236,16 @@ tBTM_STATUS btm_ble_start_encrypt(const RawAddress& bda, bool use_stk,
 
   if (use_stk) {
     btsnd_hcic_ble_start_enc(p_rec->ble_hci_handle, dummy_rand, 0, *p_stk);
-  } else if (p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PENC) {
-    btsnd_hcic_ble_start_enc(
-        p_rec->ble_hci_handle, p_rec->sec_rec.ble_keys.rand,
-        p_rec->sec_rec.ble_keys.ediv, p_rec->sec_rec.ble_keys.pltk);
+  } else if (p_rec->ble_keys.key_type & BTM_LE_KEY_PENC) {
+    btsnd_hcic_ble_start_enc(p_rec->ble_hci_handle, p_rec->ble_keys.rand,
+                             p_rec->ble_keys.ediv, p_rec->ble_keys.pltk);
   } else {
     LOG_ERROR("No key available to encrypt the link");
     return BTM_ERR_KEY_MISSING;
   }
 
-  if (p_rec->sec_rec.sec_state == BTM_SEC_STATE_IDLE)
-    p_rec->sec_rec.sec_state = BTM_SEC_STATE_LE_ENCRYPTING;
+  if (p_rec->sec_state == BTM_SEC_STATE_IDLE)
+    p_rec->sec_state = BTM_SEC_STATE_LE_ENCRYPTING;
 
   return BTM_CMD_STARTED;
 }
@@ -1312,24 +1306,23 @@ void btm_ble_link_encrypted(const RawAddress& bd_addr, uint8_t encr_enable) {
     return;
   }
 
-  enc_cback = p_dev_rec->sec_rec.is_security_state_le_encrypting();
+  enc_cback = p_dev_rec->is_security_state_le_encrypting();
 
   smp_link_encrypted(bd_addr, encr_enable);
 
-  LOG_VERBOSE("p_dev_rec->sec_rec.sec_flags=0x%x",
-              p_dev_rec->sec_rec.sec_flags);
+  LOG_VERBOSE("p_dev_rec->sec_flags=0x%x", p_dev_rec->sec_flags);
 
-  if (encr_enable && p_dev_rec->sec_rec.enc_key_size == 0)
-    p_dev_rec->sec_rec.enc_key_size = p_dev_rec->sec_rec.ble_keys.key_size;
+  if (encr_enable && p_dev_rec->enc_key_size == 0)
+    p_dev_rec->enc_key_size = p_dev_rec->ble_keys.key_size;
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
-  if (p_dev_rec->sec_rec.p_callback && enc_cback) {
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
+  if (p_dev_rec->p_callback && enc_cback) {
     if (encr_enable) btm_sec_dev_rec_cback_event(p_dev_rec, BTM_SUCCESS, true);
     /* LTK missing on peripheral */
     else if (p_dev_rec->role_central &&
-             (p_dev_rec->sec_rec.sec_status == HCI_ERR_KEY_MISSING)) {
+             (p_dev_rec->sec_status == HCI_ERR_KEY_MISSING)) {
       btm_sec_dev_rec_cback_event(p_dev_rec, BTM_ERR_KEY_MISSING, true);
-    } else if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) {
+    } else if (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) {
       btm_sec_dev_rec_cback_event(p_dev_rec, BTM_FAILED_ON_SECURITY, true);
     } else if (p_dev_rec->role_central)
       btm_sec_dev_rec_cback_event(p_dev_rec, BTM_ERR_PROCESSING, true);
@@ -1375,17 +1368,16 @@ void btm_ble_ltk_request_reply(const RawAddress& bda, bool use_stk,
   }
 
   p_cb->enc_handle = p_rec->ble_hci_handle;
-  p_cb->key_size = p_rec->sec_rec.ble_keys.key_size;
+  p_cb->key_size = p_rec->ble_keys.key_size;
 
-  LOG_ERROR("key size=%d", p_rec->sec_rec.ble_keys.key_size);
+  LOG_ERROR("key size=%d", p_rec->ble_keys.key_size);
   if (use_stk) {
     btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle, stk);
     return;
   }
   /* calculate LTK using peer device  */
-  if (p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_LENC) {
-    btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle,
-                                 p_rec->sec_rec.ble_keys.lltk);
+  if (p_rec->ble_keys.key_type & BTM_LE_KEY_LENC) {
+    btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle, p_rec->ble_keys.lltk);
     return;
   }
 
@@ -1402,10 +1394,9 @@ void btm_ble_ltk_request_reply(const RawAddress& bda, bool use_stk,
    * end up here. We will eventually consolidate both entries, this is to avoid
    * race conditions. */
 
-  LOG_ASSERT(p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_LENC);
-  p_cb->key_size = p_rec->sec_rec.ble_keys.key_size;
-  btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle,
-                               p_rec->sec_rec.ble_keys.lltk);
+  LOG_ASSERT(p_rec->ble_keys.key_type & BTM_LE_KEY_LENC);
+  p_cb->key_size = p_rec->ble_keys.key_size;
+  btsnd_hcic_ble_ltk_req_reply(btm_sec_cb.enc_handle, p_rec->ble_keys.lltk);
 }
 
 /*******************************************************************************
@@ -1431,13 +1422,13 @@ static uint8_t btm_ble_io_capabilities_req(tBTM_SEC_DEV_REC* p_dev_rec,
   if ((callback_rc == BTM_SUCCESS) || (BTM_OOB_UNKNOWN != p_data->oob_data)) {
     p_data->auth_req &= BTM_LE_AUTH_REQ_MASK;
 
-    LOG_VERBOSE("1:p_dev_rec->sec_rec.security_required=%d, auth_req:%d",
-                p_dev_rec->sec_rec.security_required, p_data->auth_req);
+    LOG_VERBOSE("1:p_dev_rec->security_required=%d, auth_req:%d",
+                p_dev_rec->security_required, p_data->auth_req);
     LOG_VERBOSE("2:i_keys=0x%x r_keys=0x%x (bit 0-LTK 1-IRK 2-CSRK)",
                 p_data->init_keys, p_data->resp_keys);
 
     /* if authentication requires MITM protection, put on the mask */
-    if (p_dev_rec->sec_rec.security_required & BTM_SEC_IN_MITM)
+    if (p_dev_rec->security_required & BTM_SEC_IN_MITM)
       p_data->auth_req |= BTM_LE_AUTH_REQ_MITM;
 
     if (!(p_data->auth_req & SMP_AUTH_BOND)) {
@@ -1583,7 +1574,7 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
       case SMP_OOB_REQ_EVT:
       case SMP_NC_REQ_EVT:
       case SMP_SC_OOB_REQ_EVT:
-        p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LE_AUTHENTICATED;
+        p_dev_rec->sec_flags |= BTM_SEC_LE_AUTHENTICATED;
         FALLTHROUGH_INTENDED; /* FALLTHROUGH */
 
       case SMP_CONSENT_REQ_EVT:
@@ -1595,7 +1586,7 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
         }
         btm_sec_cb.pairing_bda = bd_addr;
         if (event != SMP_CONSENT_REQ_EVT) {
-          p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+          p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
         }
         btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_LE_ACTIVE;
         FALLTHROUGH_INTENDED; /* FALLTHROUGH */
@@ -1617,14 +1608,13 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
             return BTM_SUCCESS;
           }
           LOG_VERBOSE("before update sec_level=0x%x sec_flags=0x%x",
-                      p_data->cmplt.sec_level, p_dev_rec->sec_rec.sec_flags);
+                      p_data->cmplt.sec_level, p_dev_rec->sec_flags);
 
           res = (p_data->cmplt.reason == SMP_SUCCESS) ? BTM_SUCCESS
                                                       : BTM_ERR_PROCESSING;
 
           LOG_VERBOSE("after update result=%d sec_level=0x%x sec_flags=0x%x",
-                      res, p_data->cmplt.sec_level,
-                      p_dev_rec->sec_rec.sec_flags);
+                      res, p_data->cmplt.sec_level, p_dev_rec->sec_flags);
 
           if (p_data->cmplt.is_pair_cancel &&
               btm_sec_cb.api.p_bond_cancel_cmpl_callback) {
@@ -1651,9 +1641,9 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
           }
 
           if (res == BTM_SUCCESS) {
-            p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+            p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
-            if (p_dev_rec->sec_rec.bond_type != BOND_TYPE_TEMPORARY) {
+            if (p_dev_rec->bond_type != BOND_TYPE_TEMPORARY) {
               // Add all bonded device into resolving list if IRK is available.
               btm_ble_resolving_list_load_dev(*p_dev_rec);
             } else if (p_dev_rec->ble_hci_handle == HCI_INVALID_HANDLE) {
@@ -1663,8 +1653,8 @@ tBTM_STATUS btm_proc_smp_cback(tSMP_EVT event, const RawAddress& bd_addr,
               LOG_DEBUG(
                   "SMP over BR triggered by temporary bond has completed,"
                   " resetting the LK flags");
-              p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
-              p_dev_rec->sec_rec.ble_keys.key_type = BTM_LE_KEY_NONE;
+              p_dev_rec->sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
+              p_dev_rec->ble_keys.key_type = BTM_LE_KEY_NONE;
             }
           }
           tBTM_BD_NAME remote_name = {};
@@ -1747,11 +1737,11 @@ bool BTM_BleDataSignature(const RawAddress& bd_addr, uint8_t* p_text,
     pp = (p_buf + len);
   }
 
-  UINT32_TO_STREAM(pp, p_rec->sec_rec.ble_keys.local_counter);
-  UINT32_TO_STREAM(p_mac, p_rec->sec_rec.ble_keys.local_counter);
+  UINT32_TO_STREAM(pp, p_rec->ble_keys.local_counter);
+  UINT32_TO_STREAM(p_mac, p_rec->ble_keys.local_counter);
 
-  crypto_toolbox::aes_cmac(p_rec->sec_rec.ble_keys.lcsrk, p_buf,
-                           (uint16_t)(len + 4), BTM_CMAC_TLEN_SIZE, p_mac);
+  crypto_toolbox::aes_cmac(p_rec->ble_keys.lcsrk, p_buf, (uint16_t)(len + 4),
+                           BTM_CMAC_TLEN_SIZE, p_mac);
   btm_ble_increment_sign_ctr(bd_addr, true);
 
   LOG_VERBOSE("p_mac = %p", p_mac);
@@ -1789,17 +1779,17 @@ bool BTM_BleVerifySignature(const RawAddress& bd_addr, uint8_t* p_orig,
   uint8_t p_mac[BTM_CMAC_TLEN_SIZE];
 
   if (p_rec == NULL ||
-      (p_rec && !(p_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_PCSRK))) {
+      (p_rec && !(p_rec->ble_keys.key_type & BTM_LE_KEY_PCSRK))) {
     LOG_ERROR("can not verify signature for unknown device");
-  } else if (counter < p_rec->sec_rec.ble_keys.counter) {
+  } else if (counter < p_rec->ble_keys.counter) {
     LOG_ERROR("signature received with out dated sign counter");
   } else if (p_orig == NULL) {
     LOG_ERROR("No signature to verify");
   } else {
     LOG_VERBOSE("rcv_cnt=%d >= expected_cnt=%d", counter,
-                p_rec->sec_rec.ble_keys.counter);
+                p_rec->ble_keys.counter);
 
-    crypto_toolbox::aes_cmac(p_rec->sec_rec.ble_keys.pcsrk, p_orig, len,
+    crypto_toolbox::aes_cmac(p_rec->ble_keys.pcsrk, p_orig, len,
                              BTM_CMAC_TLEN_SIZE, p_mac);
     if (CRYPTO_memcmp(p_mac, p_comp, BTM_CMAC_TLEN_SIZE) == 0) {
       btm_ble_increment_sign_ctr(bd_addr, false);
@@ -1992,7 +1982,7 @@ std::optional<Octet16> BTM_BleGetPeerLTK(const RawAddress address) {
     return std::nullopt;
   }
 
-  return p_dev_rec->sec_rec.ble_keys.pltk;
+  return p_dev_rec->ble_keys.pltk;
 }
 
 std::optional<Octet16> BTM_BleGetPeerIRK(const RawAddress address) {
@@ -2001,12 +1991,12 @@ std::optional<Octet16> BTM_BleGetPeerIRK(const RawAddress address) {
     return std::nullopt;
   }
 
-  return p_dev_rec->sec_rec.ble_keys.irk;
+  return p_dev_rec->ble_keys.irk;
 }
 
 bool BTM_BleIsLinkKeyKnown(const RawAddress address) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(address);
-  return p_dev_rec != nullptr && p_dev_rec->sec_rec.is_le_link_key_known();
+  return p_dev_rec != nullptr && p_dev_rec->is_le_link_key_known();
 }
 
 std::optional<tBLE_BD_ADDR> BTM_BleGetIdentityAddress(
diff --git a/system/stack/btm/btm_dev.cc b/system/stack/btm/btm_dev.cc
index 02b7f3b8e4..a3750212aa 100644
--- a/system/stack/btm/btm_dev.cc
+++ b/system/stack/btm/btm_dev.cc
@@ -57,8 +57,8 @@ constexpr char kBtmLogTag[] = "BOND";
 }
 
 static void wipe_secrets_and_remove(tBTM_SEC_DEV_REC* p_dev_rec) {
-  p_dev_rec->sec_rec.link_key.fill(0);
-  memset(&p_dev_rec->sec_rec.ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
+  p_dev_rec->link_key.fill(0);
+  memset(&p_dev_rec->ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
   list_remove(btm_sec_cb.sec_dev_rec, p_dev_rec);
 }
 
@@ -112,7 +112,7 @@ bool BTM_SecAddDevice(const RawAddress& bd_addr, DEV_CLASS dev_class,
      * bond state for an existing device here? This logic should be verified
      * as part of a larger refactor.
      */
-    p_dev_rec->sec_rec.bond_type = BOND_TYPE_UNKNOWN;
+    p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
   }
 
   if (dev_class) memcpy(p_dev_rec->dev_class, dev_class, DEV_CLASS_LEN);
@@ -122,28 +122,28 @@ bool BTM_SecAddDevice(const RawAddress& bd_addr, DEV_CLASS dev_class,
   if (bd_name && bd_name[0]) {
     LOG_DEBUG("  Remote name known for device:%s name:%s",
               ADDRESS_TO_LOGGABLE_CSTR(bd_addr), bd_name);
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_NAME_KNOWN;
+    p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
     strlcpy((char*)p_dev_rec->sec_bd_name, (char*)bd_name,
             BTM_MAX_REM_BD_NAME_LEN + 1);
   }
 
   if (p_link_key) {
     LOG_DEBUG("  Link key known for device:%s", ADDRESS_TO_LOGGABLE_CSTR(bd_addr));
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
-    p_dev_rec->sec_rec.link_key = *p_link_key;
-    p_dev_rec->sec_rec.link_key_type = key_type;
-    p_dev_rec->sec_rec.pin_code_length = pin_length;
+    p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
+    p_dev_rec->link_key = *p_link_key;
+    p_dev_rec->link_key_type = key_type;
+    p_dev_rec->pin_code_length = pin_length;
 
     if (pin_length >= 16 || key_type == BTM_LKEY_TYPE_AUTH_COMB ||
         key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
       // Set the flag if the link key was made by using either a 16 digit
       // pin or MITM.
-      p_dev_rec->sec_rec.sec_flags |=
+      p_dev_rec->sec_flags |=
           BTM_SEC_16_DIGIT_PIN_AUTHED | BTM_SEC_LINK_KEY_AUTHED;
     }
   }
 
-  p_dev_rec->sec_rec.rmt_io_caps = BTM_IO_CAP_OUT;
+  p_dev_rec->rmt_io_caps = BTM_IO_CAP_OUT;
   p_dev_rec->device_type |= BT_DEVICE_TYPE_BREDR;
 
   return true;
@@ -171,8 +171,8 @@ bool BTM_SecDeleteDevice(const RawAddress& bd_addr) {
   }
 
   /* Invalidate bonded status */
-  p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
-  p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_LINK_KEY_KNOWN;
+  p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
+  p_dev_rec->sec_flags &= ~BTM_SEC_LE_LINK_KEY_KNOWN;
 
   if (BTM_IsAclConnectionUp(bd_addr, BT_TRANSPORT_LE) ||
       BTM_IsAclConnectionUp(bd_addr, BT_TRANSPORT_BR_EDR)) {
@@ -195,7 +195,7 @@ bool BTM_SecDeleteDevice(const RawAddress& bd_addr) {
   }
 
   const auto device_type = p_dev_rec->device_type;
-  const auto bond_type = p_dev_rec->sec_rec.bond_type;
+  const auto bond_type = p_dev_rec->bond_type;
 
   /* Clear out any saved BLE keys */
   btm_sec_clear_ble_keys(p_dev_rec);
@@ -223,8 +223,8 @@ void BTM_SecClearSecurityFlags(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
   if (p_dev_rec == NULL) return;
 
-  p_dev_rec->sec_rec.sec_flags = 0;
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_flags = 0;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
   p_dev_rec->sm4 = BTM_SM4_UNKNOWN;
 }
 
@@ -401,7 +401,7 @@ tBTM_SEC_DEV_REC* btm_find_dev(const RawAddress& bd_addr) {
 
 static bool has_lenc_and_address_is_equal(void* data, void* context) {
   tBTM_SEC_DEV_REC* p_dev_rec = static_cast<tBTM_SEC_DEV_REC*>(data);
-  if (!(p_dev_rec->sec_rec.ble_keys.key_type & BTM_LE_KEY_LENC)) return true;
+  if (!(p_dev_rec->ble_keys.key_type & BTM_LE_KEY_LENC)) return true;
 
   return is_address_equal(data, context);
 }
@@ -454,14 +454,14 @@ void btm_consolidate_dev(tBTM_SEC_DEV_REC* p_target_rec) {
       memcpy(p_target_rec, p_dev_rec, sizeof(tBTM_SEC_DEV_REC));
       p_target_rec->ble = temp_rec.ble;
       p_target_rec->ble_hci_handle = temp_rec.ble_hci_handle;
-      p_target_rec->sec_rec.enc_key_size = temp_rec.sec_rec.enc_key_size;
+      p_target_rec->enc_key_size = temp_rec.enc_key_size;
       p_target_rec->conn_params = temp_rec.conn_params;
       p_target_rec->device_type |= temp_rec.device_type;
-      p_target_rec->sec_rec.sec_flags |= temp_rec.sec_rec.sec_flags;
+      p_target_rec->sec_flags |= temp_rec.sec_flags;
 
-      p_target_rec->sec_rec.new_encryption_key_is_p256 =
-          temp_rec.sec_rec.new_encryption_key_is_p256;
-      p_target_rec->sec_rec.bond_type = temp_rec.sec_rec.bond_type;
+      p_target_rec->new_encryption_key_is_p256 =
+          temp_rec.new_encryption_key_is_p256;
+      p_target_rec->bond_type = temp_rec.bond_type;
 
       /* remove the combined record */
       wipe_secrets_and_remove(p_dev_rec);
@@ -595,7 +595,7 @@ static tBTM_SEC_DEV_REC* btm_find_oldest_dev_rec(void) {
     tBTM_SEC_DEV_REC* p_dev_rec =
         static_cast<tBTM_SEC_DEV_REC*>(list_node(node));
 
-    if ((p_dev_rec->sec_rec.sec_flags &
+    if ((p_dev_rec->sec_flags &
          (BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LE_LINK_KEY_KNOWN)) == 0) {
       // Device is not paired
       if (p_dev_rec->timestamp < ts_oldest) {
@@ -642,10 +642,10 @@ tBTM_SEC_DEV_REC* btm_sec_allocate_dev_rec(void) {
   list_append(btm_sec_cb.sec_dev_rec, p_dev_rec);
 
   // Initialize defaults
-  p_dev_rec->sec_rec.sec_flags = BTM_SEC_IN_USE;
-  p_dev_rec->sec_rec.bond_type = BOND_TYPE_UNKNOWN;
+  p_dev_rec->sec_flags = BTM_SEC_IN_USE;
+  p_dev_rec->bond_type = BOND_TYPE_UNKNOWN;
   p_dev_rec->timestamp = btm_sec_cb.dev_rec_count++;
-  p_dev_rec->sec_rec.rmt_io_caps = BTM_IO_CAP_UNKNOWN;
+  p_dev_rec->rmt_io_caps = BTM_IO_CAP_UNKNOWN;
   p_dev_rec->suggested_tx_octets = 0;
 
   return p_dev_rec;
@@ -666,7 +666,7 @@ tBTM_BOND_TYPE btm_get_bond_type_dev(const RawAddress& bd_addr) {
 
   if (p_dev_rec == NULL) return BOND_TYPE_UNKNOWN;
 
-  return p_dev_rec->sec_rec.bond_type;
+  return p_dev_rec->bond_type;
 }
 
 /*******************************************************************************
@@ -685,7 +685,7 @@ bool btm_set_bond_type_dev(const RawAddress& bd_addr,
 
   if (p_dev_rec == NULL) return false;
 
-  p_dev_rec->sec_rec.bond_type = bond_type;
+  p_dev_rec->bond_type = bond_type;
   return true;
 }
 
@@ -790,7 +790,7 @@ const tBLE_BD_ADDR BTM_Sec_GetAddressWithType(const RawAddress& bd_addr) {
 
 bool BTM_IsRemoteNameKnown(const RawAddress& bd_addr, tBT_TRANSPORT transport) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
-  return (p_dev_rec == nullptr) ? false : p_dev_rec->sec_rec.is_name_known();
+  return (p_dev_rec == nullptr) ? false : p_dev_rec->is_name_known();
 }
 
 namespace bluetooth {
diff --git a/system/stack/btm/btm_devctl.cc b/system/stack/btm/btm_devctl.cc
index 61a208b246..a89c5788b0 100644
--- a/system/stack/btm/btm_devctl.cc
+++ b/system/stack/btm/btm_devctl.cc
@@ -162,7 +162,7 @@ void BTM_db_reset(void) {
 
 static bool set_sec_state_idle(void* data, void* context) {
   tBTM_SEC_DEV_REC* p_dev_rec = static_cast<tBTM_SEC_DEV_REC*>(data);
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
   return true;
 }
 
diff --git a/system/stack/btm/btm_sec.cc b/system/stack/btm/btm_sec.cc
index cdb18ee4e6..020e2803f1 100644
--- a/system/stack/btm/btm_sec.cc
+++ b/system/stack/btm/btm_sec.cc
@@ -196,7 +196,7 @@ void NotifyBondingCanceled(tBTM_STATUS btm_status) {
  *
  ******************************************************************************/
 static bool btm_dev_authenticated(const tBTM_SEC_DEV_REC* p_dev_rec) {
-  return p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED;
+  return p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED;
 }
 
 /*******************************************************************************
@@ -209,7 +209,7 @@ static bool btm_dev_authenticated(const tBTM_SEC_DEV_REC* p_dev_rec) {
  *
  ******************************************************************************/
 static bool btm_dev_encrypted(const tBTM_SEC_DEV_REC* p_dev_rec) {
-  return p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED;
+  return p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED;
 }
 
 /*******************************************************************************
@@ -223,14 +223,14 @@ static bool btm_dev_encrypted(const tBTM_SEC_DEV_REC* p_dev_rec) {
  ******************************************************************************/
 static bool btm_dev_16_digit_authenticated(const tBTM_SEC_DEV_REC* p_dev_rec) {
   // BTM_SEC_16_DIGIT_PIN_AUTHED is set if MITM or 16 digit pin is used
-  return p_dev_rec->sec_rec.sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED;
+  return p_dev_rec->sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED;
 }
 
 static bool is_sec_state_equal(void* data, void* context) {
   tBTM_SEC_DEV_REC* p_dev_rec = static_cast<tBTM_SEC_DEV_REC*>(data);
   uint8_t* state = static_cast<uint8_t*>(context);
 
-  if (p_dev_rec->sec_rec.sec_state == *state) return false;
+  if (p_dev_rec->sec_state == *state) return false;
 
   return true;
 }
@@ -268,8 +268,8 @@ static bool access_secure_service_from_temp_bond(const tBTM_SEC_DEV_REC* p_dev_r
                                                  bool locally_initiated,
                                                  uint16_t security_req) {
   return !locally_initiated && (security_req & BTM_SEC_IN_AUTHENTICATE) &&
-         p_dev_rec->sec_rec.is_device_authenticated() &&
-         p_dev_rec->sec_rec.is_bond_type_temporary();
+    p_dev_rec->is_device_authenticated() &&
+    p_dev_rec->is_bond_type_temporary();
 }
 
 /*******************************************************************************
@@ -404,9 +404,9 @@ bool BTM_GetSecurityFlagsByTransport(const RawAddress& bd_addr,
   p_dev_rec = btm_find_dev(bd_addr);
   if (p_dev_rec != NULL) {
     if (transport == BT_TRANSPORT_BR_EDR)
-      *p_sec_flags = (uint8_t)p_dev_rec->sec_rec.sec_flags;
+      *p_sec_flags = (uint8_t)p_dev_rec->sec_flags;
     else
-      *p_sec_flags = (uint8_t)(p_dev_rec->sec_rec.sec_flags >> 8);
+      *p_sec_flags = (uint8_t)(p_dev_rec->sec_flags >> 8);
 
     return (true);
   }
@@ -708,15 +708,15 @@ void BTM_PINCodeReply(const RawAddress& bd_addr, tBTM_STATUS res,
 
       btsnd_hcic_pin_code_neg_reply(bd_addr);
     } else {
-      p_dev_rec->sec_rec.security_required = BTM_SEC_NONE;
+      p_dev_rec->security_required = BTM_SEC_NONE;
       btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
     }
     return;
   }
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
-  p_dev_rec->sec_rec.pin_code_length = pin_len;
+  p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
+  p_dev_rec->pin_code_length = pin_len;
   if (pin_len >= 16) {
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+    p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
   }
 
   if ((btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
@@ -751,7 +751,7 @@ void BTM_PINCodeReply(const RawAddress& bd_addr, tBTM_STATUS res,
       btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_PIN_REQ);
     } else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED) {
       btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
-      p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;
+      p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;
 
       NotifyBondingChange(*p_dev_rec, HCI_ERR_AUTH_FAILURE);
     }
@@ -802,15 +802,15 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
     return (BTM_NO_RESOURCES);
   }
 
-  LOG_VERBOSE("before update sec_flags=0x%x", p_dev_rec->sec_rec.sec_flags);
+  LOG_VERBOSE("before update sec_flags=0x%x", p_dev_rec->sec_flags);
 
   /* Finished if connection is active and already paired */
   if (((p_dev_rec->hci_handle != HCI_INVALID_HANDLE) &&
        transport == BT_TRANSPORT_BR_EDR &&
-       (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) ||
+       (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) ||
       ((p_dev_rec->ble_hci_handle != HCI_INVALID_HANDLE) &&
        transport == BT_TRANSPORT_LE &&
-       (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_AUTHENTICATED))) {
+       (p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED))) {
     LOG_WARN("BTM_SecBond -> Already Paired");
     return (BTM_SUCCESS);
   }
@@ -825,7 +825,7 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
 
   btm_sec_cb.pairing_flags = BTM_PAIR_FLAGS_WE_STARTED_DD;
 
-  p_dev_rec->sec_rec.security_required = BTM_SEC_OUT_AUTHENTICATE;
+  p_dev_rec->security_required = BTM_SEC_OUT_AUTHENTICATE;
   p_dev_rec->is_originator = true;
 
   BTM_LogHistory(kBtmLogTag, bd_addr, "Bonding initiated",
@@ -833,11 +833,11 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
 
   if (transport == BT_TRANSPORT_LE) {
     btm_ble_init_pseudo_addr(p_dev_rec, bd_addr);
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_MASK;
+    p_dev_rec->sec_flags &= ~BTM_SEC_LE_MASK;
 
     if (SMP_Pair(bd_addr, addr_type) == SMP_STARTED) {
       btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_LE_ACTIVE;
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+      p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
       btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
       return BTM_CMD_STARTED;
     }
@@ -846,11 +846,11 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
     return (BTM_NO_RESOURCES);
   }
 
-  p_dev_rec->sec_rec.sec_flags &=
+  p_dev_rec->sec_flags &=
       ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED |
         BTM_SEC_ROLE_SWITCHED | BTM_SEC_LINK_KEY_AUTHED);
 
-  LOG_VERBOSE("after update sec_flags=0x%x", p_dev_rec->sec_rec.sec_flags);
+  LOG_VERBOSE("after update sec_flags=0x%x", p_dev_rec->sec_flags);
   if (!controller_get_interface()->supports_simple_pairing()) {
     /* The special case when we authenticate keyboard.  Set pin type to fixed */
     /* It would be probably better to do it from the application, but it is */
@@ -868,7 +868,7 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
               p_dev_rec->sm4, p_dev_rec->hci_handle);
 
 #if (BTM_SEC_FORCE_RNR_FOR_DBOND == TRUE)
-  p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_NAME_KNOWN;
+  p_dev_rec->sec_flags &= ~BTM_SEC_NAME_KNOWN;
 #endif
 
   /* If connection already exists... */
@@ -904,7 +904,7 @@ tBTM_STATUS btm_sec_bond_by_transport(const RawAddress& bd_addr,
     }
     LOG_VERBOSE("State:%s sm4: 0x%x sec_state:%d",
                 btm_pair_state_descr(btm_sec_cb.pairing_state), p_dev_rec->sm4,
-                p_dev_rec->sec_rec.sec_state);
+                p_dev_rec->sec_state);
   } else {
     /* both local and peer are 2.1  */
     status = btm_sec_dd_create_conn(p_dev_rec);
@@ -981,7 +981,7 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
   }
 
   if (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_LE_ACTIVE) {
-    if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+    if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
       LOG_VERBOSE("Cancel LE pairing");
       if (SMP_PairCancel(bd_addr)) {
         return BTM_CMD_STARTED;
@@ -991,7 +991,7 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
   }
 
   LOG_VERBOSE("hci_handle:0x%x sec_state:%d", p_dev_rec->hci_handle,
-              p_dev_rec->sec_rec.sec_state);
+              p_dev_rec->sec_state);
   if (BTM_PAIR_STATE_WAIT_LOCAL_PIN == btm_sec_cb.pairing_state &&
       BTM_PAIR_FLAGS_WE_STARTED_DD & btm_sec_cb.pairing_flags) {
     /* pre-fetching pin for dedicated bonding */
@@ -1005,8 +1005,8 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
     /* If the HCI link is up */
     if (p_dev_rec->hci_handle != HCI_INVALID_HANDLE) {
       /* If some other thread disconnecting, we do not send second command */
-      if ((p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_DISCONNECTING) ||
-          (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH))
+      if ((p_dev_rec->sec_state == BTM_SEC_STATE_DISCONNECTING) ||
+          (p_dev_rec->sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH))
         return (BTM_CMD_STARTED);
 
       /* If the HCI link was set up by Bonding process */
@@ -1054,9 +1054,8 @@ tBTM_STATUS BTM_SecBondCancel(const RawAddress& bd_addr) {
 tBTM_LINK_KEY_TYPE BTM_SecGetDeviceLinkKeyType(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
 
-  if ((p_dev_rec != NULL) &&
-      (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
-    return p_dev_rec->sec_rec.link_key_type;
+  if ((p_dev_rec != NULL) && (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
+    return p_dev_rec->link_key_type;
   }
   return BTM_LKEY_TYPE_IGNORE;
 }
@@ -1113,7 +1112,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         }
         return BTM_WRONG_MODE;
       }
-      if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED) {
+      if (p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED) {
         LOG_DEBUG(
             "Security Manager: BTM_SetEncryption already encrypted peer:%s "
             "transport:%s",
@@ -1140,7 +1139,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         }
         return BTM_WRONG_MODE;
       }
-      if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_ENCRYPTED) {
+      if (p_dev_rec->sec_flags & BTM_SEC_LE_ENCRYPTED) {
         LOG_DEBUG(
             "Security Manager: BTM_SetEncryption already encrypted peer:%s "
             "transport:%s",
@@ -1162,7 +1161,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
   /* Enqueue security request if security is active */
   if (bluetooth::common::init_flags::encryption_in_busy_state_is_enabled()) {
     bool enqueue = false;
-    switch (p_dev_rec->sec_rec.sec_state) {
+    switch (p_dev_rec->sec_state) {
       case BTM_SEC_STATE_AUTHENTICATING:
       case BTM_SEC_STATE_DISCONNECTING_BOTH:
         /* Applicable for both transports */
@@ -1184,7 +1183,7 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         break;
 
       default:
-        if (p_dev_rec->sec_rec.p_callback != nullptr) {
+        if (p_dev_rec->p_callback != nullptr) {
           enqueue = true;
         }
         break;
@@ -1192,14 +1191,13 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
 
     if (enqueue) {
       LOG_WARN("Security Manager: Enqueue request in state:%s",
-               security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+               security_state_text(p_dev_rec->sec_state).c_str());
       btm_sec_queue_encrypt_request(bd_addr, transport, p_callback, p_ref_data,
                                     sec_act);
       return BTM_CMD_STARTED;
     }
   } else {
-    if (p_dev_rec->sec_rec.p_callback ||
-        (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_IDLE)) {
+    if (p_dev_rec->p_callback || (p_dev_rec->sec_state != BTM_SEC_STATE_IDLE)) {
       LOG_WARN("Security Manager: BTM_SetEncryption busy, enqueue request");
       btm_sec_queue_encrypt_request(bd_addr, transport, p_callback, p_ref_data,
                                     sec_act);
@@ -1208,9 +1206,9 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
     }
   }
 
-  p_dev_rec->sec_rec.p_callback = p_callback;
-  p_dev_rec->sec_rec.p_ref_data = p_ref_data;
-  p_dev_rec->sec_rec.security_required |=
+  p_dev_rec->p_callback = p_callback;
+  p_dev_rec->p_ref_data = p_ref_data;
+  p_dev_rec->security_required |=
       (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT);
   p_dev_rec->is_originator = false;
 
@@ -1218,9 +1216,9 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
       "Security Manager: BTM_SetEncryption classic_handle:0x%04x "
       "ble_handle:0x%04x state:%d flags:0x%x "
       "required:0x%x p_callback=%c",
-      p_dev_rec->hci_handle, p_dev_rec->ble_hci_handle,
-      p_dev_rec->sec_rec.sec_state, p_dev_rec->sec_rec.sec_flags,
-      p_dev_rec->sec_rec.security_required, (p_callback) ? 'T' : 'F');
+      p_dev_rec->hci_handle, p_dev_rec->ble_hci_handle, p_dev_rec->sec_state,
+      p_dev_rec->sec_flags, p_dev_rec->security_required,
+      (p_callback) ? 'T' : 'F');
 
   tBTM_STATUS rc = BTM_SUCCESS;
   switch (transport) {
@@ -1253,11 +1251,10 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
         LOG_DEBUG("Executing encryption callback peer:%s transport:%s",
                   ADDRESS_TO_LOGGABLE_CSTR(bd_addr),
                   bt_transport_text(transport).c_str());
-        p_dev_rec->sec_rec.p_callback = nullptr;
-        do_in_main_thread(
-            FROM_HERE,
-            base::BindOnce(p_callback, std::move(owned_bd_addr), transport,
-                           p_dev_rec->sec_rec.p_ref_data, rc));
+        p_dev_rec->p_callback = nullptr;
+        do_in_main_thread(FROM_HERE,
+                          base::BindOnce(p_callback, std::move(owned_bd_addr),
+                                         transport, p_dev_rec->p_ref_data, rc));
       }
       break;
   }
@@ -1266,9 +1263,8 @@ tBTM_STATUS BTM_SetEncryption(const RawAddress& bd_addr,
 
 bool BTM_SecIsSecurityPending(const RawAddress& bd_addr) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bd_addr);
-  return p_dev_rec &&
-         (p_dev_rec->sec_rec.is_security_state_encrypting() ||
-          p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING);
+  return p_dev_rec && (p_dev_rec->is_security_state_encrypting() ||
+                       p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING);
 }
 
 /*******************************************************************************
@@ -1279,7 +1275,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
                                                uint16_t conn_handle,
                                                std::string comment) {
   const tSECURITY_STATE old_state =
-      static_cast<tSECURITY_STATE>(p_dev_rec->sec_rec.sec_state);
+      static_cast<tSECURITY_STATE>(p_dev_rec->sec_state);
   const tBTM_STATUS status = BTM_CMD_STARTED;
 
   /* send HCI_Disconnect on a transport only once */
@@ -1290,7 +1286,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
         return status;
       }
       // Prepare to send disconnect on le transport
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
+      p_dev_rec->sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
       break;
 
     case BTM_SEC_STATE_DISCONNECTING_BLE:
@@ -1299,7 +1295,7 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
         return status;
       }
       // Prepare to send disconnect on classic transport
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
+      p_dev_rec->sec_state = BTM_SEC_STATE_DISCONNECTING_BOTH;
       break;
 
     case BTM_SEC_STATE_DISCONNECTING_BOTH:
@@ -1307,9 +1303,9 @@ static tBTM_STATUS btm_sec_send_hci_disconnect(tBTM_SEC_DEV_REC* p_dev_rec,
       return status;
 
     default:
-      p_dev_rec->sec_rec.sec_state = (conn_handle == p_dev_rec->hci_handle)
-                                         ? BTM_SEC_STATE_DISCONNECTING
-                                         : BTM_SEC_STATE_DISCONNECTING_BLE;
+      p_dev_rec->sec_state = (conn_handle == p_dev_rec->hci_handle)
+                                 ? BTM_SEC_STATE_DISCONNECTING
+                                 : BTM_SEC_STATE_DISCONNECTING_BLE;
 
       break;
   }
@@ -1403,7 +1399,7 @@ void BTM_PasskeyReqReply(tBTM_STATUS res, const RawAddress& bd_addr,
       else
         BTM_SecBondCancel(bd_addr);
 
-      p_dev_rec->sec_rec.sec_flags &=
+      p_dev_rec->sec_flags &=
           ~(BTM_SEC_LINK_KEY_AUTHED | BTM_SEC_LINK_KEY_KNOWN);
 
       btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
@@ -1576,22 +1572,20 @@ static bool btm_sec_is_upgrade_possible(tBTM_SEC_DEV_REC* p_dev_rec,
   uint16_t mtm_check = is_originator ? BTM_SEC_OUT_MITM : BTM_SEC_IN_MITM;
   bool is_possible = true;
 
-  if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
+  if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
     is_possible = false;
     /* Already have a link key to the connected peer. Is the link key secure
      *enough?
      ** Is a link key upgrade even possible?
      */
-    if ((p_dev_rec->sec_rec.security_required & mtm_check) /* needs MITM */
-        &&
-        ((p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB) ||
-         (p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256))
+    if ((p_dev_rec->security_required & mtm_check) /* needs MITM */
+        && ((p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB) ||
+            (p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256))
         /* has unauthenticated
         link key */
-        && (p_dev_rec->sec_rec.rmt_io_caps <
-            BTM_IO_CAP_MAX) /* a valid peer IO cap */
-        && (btm_sec_io_map[p_dev_rec->sec_rec.rmt_io_caps]
-                          [btm_sec_cb.devcb.loc_io_caps]))
+        && (p_dev_rec->rmt_io_caps < BTM_IO_CAP_MAX) /* a valid peer IO cap */
+        &&
+        (btm_sec_io_map[p_dev_rec->rmt_io_caps][btm_sec_cb.devcb.loc_io_caps]))
     /* authenticated
     link key is possible */
     {
@@ -1603,7 +1597,7 @@ static bool btm_sec_is_upgrade_possible(tBTM_SEC_DEV_REC* p_dev_rec,
     }
   }
   LOG_VERBOSE("is_possible: %d sec_flags: 0x%x", is_possible,
-              p_dev_rec->sec_rec.sec_flags);
+              p_dev_rec->sec_flags);
   return is_possible;
 }
 
@@ -1622,18 +1616,17 @@ static void btm_sec_check_upgrade(tBTM_SEC_DEV_REC* p_dev_rec,
   LOG_VERBOSE("verify whether the link key should be upgraded");
 
   /* Only check if link key already exists */
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN)) return;
+  if (!(p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)) return;
 
   if (btm_sec_is_upgrade_possible(p_dev_rec, is_originator)) {
-    LOG_VERBOSE("need upgrade!! sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+    LOG_VERBOSE("need upgrade!! sec_flags:0x%x", p_dev_rec->sec_flags);
     /* if the application confirms the upgrade, set the upgrade bit */
     p_dev_rec->sm4 |= BTM_SM4_UPGRADE;
 
     /* Clear the link key known to go through authentication/pairing again */
-    p_dev_rec->sec_rec.sec_flags &=
-        ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED);
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_AUTHENTICATED;
-    LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+    p_dev_rec->sec_flags &= ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED);
+    p_dev_rec->sec_flags &= ~BTM_SEC_AUTHENTICATED;
+    LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_flags);
   }
 }
 
@@ -1679,10 +1672,10 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   /* there are some devices (moto KRZR) which connects to several services at
    * the same time */
   /* we will process one after another */
-  if ((p_dev_rec->sec_rec.p_callback) ||
+  if ((p_dev_rec->p_callback) ||
       (btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE)) {
     LOG_DEBUG("security_flags:x%x, sec_flags:x%x", security_required,
-              p_dev_rec->sec_rec.sec_flags);
+              p_dev_rec->sec_flags);
     rc = BTM_CMD_STARTED;
     if ((btm_sec_cb.security_mode == BTM_SEC_MODE_SERVICE) ||
         (BTM_SM4_KNOWN == p_dev_rec->sm4) ||
@@ -1719,7 +1712,7 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
       }
 
       if ((rc == BTM_SUCCESS) && (security_required & BTM_SEC_MODE4_LEVEL4) &&
-          (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+          (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
         rc = BTM_CMD_STARTED;
       }
 
@@ -1740,7 +1733,7 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   }
 
   /* Save the security requirements in case a pairing is needed */
-  p_dev_rec->sec_rec.required_security_flags_for_pairing = security_required;
+  p_dev_rec->required_security_flags_for_pairing = security_required;
 
   /* Modify security_required in btm_sec_l2cap_access_req for Lisbon */
   if (btm_sec_cb.security_mode == BTM_SEC_MODE_SP ||
@@ -1761,8 +1754,7 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
       /* the remote features are not known yet */
       LOG_DEBUG(
           "Remote features have not yet been received sec_flags:0x%02x %s",
-          p_dev_rec->sec_rec.sec_flags,
-          (is_originator) ? "initiator" : "acceptor");
+          p_dev_rec->sec_flags, (is_originator) ? "initiator" : "acceptor");
 
       p_dev_rec->sm4 |= BTM_SM4_REQ_PEND;
       return (BTM_CMD_STARTED);
@@ -1770,23 +1762,23 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   }
 
   LOG_VERBOSE("sm4:0x%x, sec_flags:0x%x, security_required:0x%x chk:%d",
-              p_dev_rec->sm4, p_dev_rec->sec_rec.sec_flags, security_required,
+              p_dev_rec->sm4, p_dev_rec->sec_flags, security_required,
               chk_acp_auth_done);
 
-  p_dev_rec->sec_rec.security_required = security_required;
-  p_dev_rec->sec_rec.p_ref_data = p_ref_data;
+  p_dev_rec->security_required = security_required;
+  p_dev_rec->p_ref_data = p_ref_data;
   p_dev_rec->is_originator = is_originator;
 
   if (chk_acp_auth_done) {
     LOG_VERBOSE(
         "(SM4 to SM4) btm_sec_l2cap_access_req rspd. authenticated: x%x, enc: "
         "x%x",
-        (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED),
-        (p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED));
+        (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED),
+        (p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED));
     /* SM4, but we do not know for sure which level of security we need.
      * as long as we have a link key, it's OK */
-    if ((0 == (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) ||
-        (0 == (p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED))) {
+    if ((0 == (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) ||
+        (0 == (p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED))) {
       rc = BTM_DELAY_CHECK;
       /*
       2046 may report HCI_Encryption_Change and L2C Connection Request out of
@@ -1795,28 +1787,28 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
       */
       LOG_INFO(
           "peer should have initiated security process by now (SM4 to SM4)");
-      p_dev_rec->sec_rec.p_callback = p_callback;
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_DELAY_FOR_ENC;
+      p_dev_rec->p_callback = p_callback;
+      p_dev_rec->sec_state = BTM_SEC_STATE_DELAY_FOR_ENC;
       (*p_callback)(&bd_addr, transport, p_ref_data, rc);
 
       return BTM_SUCCESS;
     }
   }
 
-  p_dev_rec->sec_rec.p_callback = p_callback;
+  p_dev_rec->p_callback = p_callback;
 
   if (BTM_SEC_IS_SM4(p_dev_rec->sm4)) {
-    if ((p_dev_rec->sec_rec.security_required & BTM_SEC_MODE4_LEVEL4) &&
-        (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+    if ((p_dev_rec->security_required & BTM_SEC_MODE4_LEVEL4) &&
+        (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
       /* BTM_LKEY_TYPE_AUTH_COMB_P_256 is the only acceptable key in this case
        */
-      if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
+      if ((p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
         p_dev_rec->sm4 |= BTM_SM4_UPGRADE;
       }
-      p_dev_rec->sec_rec.sec_flags &=
+      p_dev_rec->sec_flags &=
           ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED |
             BTM_SEC_AUTHENTICATED);
-      LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+      LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_flags);
     } else {
       /* If we already have a link key to the connected peer, is it secure
        * enough? */
@@ -1827,9 +1819,9 @@ tBTM_STATUS btm_sec_l2cap_access_req_by_requirement(
   rc = btm_sec_execute_procedure(p_dev_rec);
   if (rc != BTM_CMD_STARTED) {
     LOG_VERBOSE("p_dev_rec=%p, clearing callback. old p_callback=%p", p_dev_rec,
-                p_dev_rec->sec_rec.p_callback);
-    p_dev_rec->sec_rec.p_callback = NULL;
-    (*p_callback)(&bd_addr, transport, p_dev_rec->sec_rec.p_ref_data, rc);
+                p_dev_rec->p_callback);
+    p_dev_rec->p_callback = NULL;
+    (*p_callback)(&bd_addr, transport, p_dev_rec->p_ref_data, rc);
   }
 
   return (rc);
@@ -1932,7 +1924,7 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
   /* there are some devices (moto phone) which connects to several services at
    * the same time */
   /* we will process one after another */
-  if ((p_dev_rec->sec_rec.p_callback) ||
+  if ((p_dev_rec->p_callback) ||
       (btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE)) {
     LOG_DEBUG("Pairing in progress pairing_state:%s",
               btm_pair_state_descr(btm_sec_cb.pairing_state));
@@ -1973,13 +1965,13 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
         }
       }
       if ((rc == BTM_SUCCESS) && (security_required & BTM_SEC_MODE4_LEVEL4) &&
-          (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+          (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
         rc = BTM_CMD_STARTED;
       }
     }
 
     /* the new security request */
-    if (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_IDLE) {
+    if (p_dev_rec->sec_state != BTM_SEC_STATE_IDLE) {
       LOG_DEBUG("A pending security procedure in progress");
       rc = BTM_CMD_STARTED;
     }
@@ -2028,24 +2020,24 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
     security_required |= BTM_SEC_IN_MITM;
   }
 
-  p_dev_rec->sec_rec.required_security_flags_for_pairing = security_required;
-  p_dev_rec->sec_rec.security_required = security_required;
+  p_dev_rec->required_security_flags_for_pairing = security_required;
+  p_dev_rec->security_required = security_required;
 
   if (btm_sec_cb.security_mode == BTM_SEC_MODE_SP ||
       btm_sec_cb.security_mode == BTM_SEC_MODE_SC) {
     if (BTM_SEC_IS_SM4(p_dev_rec->sm4)) {
-      if ((p_dev_rec->sec_rec.security_required & BTM_SEC_MODE4_LEVEL4) &&
-          (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+      if ((p_dev_rec->security_required & BTM_SEC_MODE4_LEVEL4) &&
+          (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
         /* BTM_LKEY_TYPE_AUTH_COMB_P_256 is the only acceptable key in this case
          */
-        if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
+        if ((p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) != 0) {
           p_dev_rec->sm4 |= BTM_SM4_UPGRADE;
         }
 
-        p_dev_rec->sec_rec.sec_flags &=
+        p_dev_rec->sec_flags &=
             ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED |
               BTM_SEC_AUTHENTICATED);
-        LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_rec.sec_flags);
+        LOG_VERBOSE("sec_flags:0x%x", p_dev_rec->sec_flags);
       } else {
         LOG_DEBUG("Already have link key; checking if link key is sufficient");
         btm_sec_check_upgrade(p_dev_rec, is_originator);
@@ -2054,8 +2046,8 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
   }
 
   p_dev_rec->is_originator = is_originator;
-  p_dev_rec->sec_rec.p_callback = p_callback;
-  p_dev_rec->sec_rec.p_ref_data = p_ref_data;
+  p_dev_rec->p_callback = p_callback;
+  p_dev_rec->p_ref_data = p_ref_data;
 
   rc = btm_sec_execute_procedure(p_dev_rec);
   LOG_DEBUG("Started security procedure peer:%s btm_status:%s",
@@ -2063,7 +2055,7 @@ tBTM_STATUS btm_sec_mx_access_request(const RawAddress& bd_addr,
             btm_status_text(rc).c_str());
   if (rc != BTM_CMD_STARTED) {
     if (p_callback) {
-      p_dev_rec->sec_rec.p_callback = NULL;
+      p_dev_rec->p_callback = NULL;
       (*p_callback)(&bd_addr, transport, p_ref_data, rc);
     }
   }
@@ -2132,7 +2124,7 @@ static void btm_sec_bond_cancel_complete(void) {
      * this function also needs to do proper clean up.
      */
     p_dev_rec = btm_find_dev(btm_sec_cb.pairing_bda);
-    if (p_dev_rec != NULL) p_dev_rec->sec_rec.security_required = BTM_SEC_NONE;
+    if (p_dev_rec != NULL) p_dev_rec->security_required = BTM_SEC_NONE;
     btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
     /* Notify application that the cancel succeeded */
@@ -2266,15 +2258,15 @@ void btm_sec_abort_access_req(const RawAddress& bd_addr) {
 
   if (!p_dev_rec) return;
 
-  if ((p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_AUTHORIZING) &&
-      (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_AUTHENTICATING))
+  if ((p_dev_rec->sec_state != BTM_SEC_STATE_AUTHORIZING) &&
+      (p_dev_rec->sec_state != BTM_SEC_STATE_AUTHENTICATING))
     return;
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
   LOG_VERBOSE("clearing callback. p_dev_rec=%p, p_callback=%p", p_dev_rec,
-              p_dev_rec->sec_rec.p_callback);
-  p_dev_rec->sec_rec.p_callback = NULL;
+              p_dev_rec->p_callback);
+  p_dev_rec->p_callback = NULL;
 }
 
 /*******************************************************************************
@@ -2395,34 +2387,34 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
     return;
   }
 
-  old_sec_state = p_dev_rec->sec_rec.sec_state;
+  old_sec_state = p_dev_rec->sec_state;
   if (status == HCI_SUCCESS) {
     LOG_DEBUG(
         "Remote read request complete for known device pairing_state:%s "
         "name:%s sec_state:%s",
         btm_pair_state_descr(btm_sec_cb.pairing_state), p_bd_name,
-        security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+        security_state_text(p_dev_rec->sec_state).c_str());
 
     strlcpy((char*)p_dev_rec->sec_bd_name, (const char*)p_bd_name,
             BTM_MAX_REM_BD_NAME_LEN + 1);
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_NAME_KNOWN;
+    p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
     LOG_VERBOSE("setting BTM_SEC_NAME_KNOWN sec_flags:0x%x",
-                p_dev_rec->sec_rec.sec_flags);
+                p_dev_rec->sec_flags);
   } else {
     LOG_WARN(
         "Remote read request failed for known device pairing_state:%s "
         "status:%s name:%s sec_state:%s",
         btm_pair_state_descr(btm_sec_cb.pairing_state),
         hci_status_code_text(status).c_str(), p_bd_name,
-        security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+        security_state_text(p_dev_rec->sec_state).c_str());
 
     /* Notify all clients waiting for name to be resolved even if it failed so
      * clients can continue */
     p_dev_rec->sec_bd_name[0] = 0;
   }
 
-  if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_GETTING_NAME)
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  if (p_dev_rec->sec_state == BTM_SEC_STATE_GETTING_NAME)
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
   /* Notify all clients waiting for name to be resolved */
   call_registered_rmt_name_callbacks(p_bd_addr, p_dev_rec->dev_class,
@@ -2443,7 +2435,7 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
       btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
       (*btm_sec_cb.api.p_pin_callback)(
           p_dev_rec->bd_addr, p_dev_rec->dev_class, p_bd_name,
-          (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+          (p_dev_rec->required_security_flags_for_pairing &
            BTM_SEC_IN_MIN_16_DIGIT_PIN));
     }
 
@@ -2531,19 +2523,19 @@ void btm_sec_rmt_name_request_complete(const RawAddress* p_bd_addr,
 
   /* check if we were delaying link_key_callback because name was not resolved
    */
-  if (p_dev_rec->sec_rec.link_key_not_sent) {
+  if (p_dev_rec->link_key_not_sent) {
     /* If HCI connection complete has not arrived, wait for it */
     if (p_dev_rec->hci_handle == HCI_INVALID_HANDLE) return;
 
-    p_dev_rec->sec_rec.link_key_not_sent = false;
+    p_dev_rec->link_key_not_sent = false;
     btm_send_link_key_notif(p_dev_rec);
   }
 
   /* If this is a bonding procedure can disconnect the link now */
   if ((btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
-      (p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) {
+      (p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) {
     LOG_WARN("btm_sec_rmt_name_request_complete (none/ce)");
-    p_dev_rec->sec_rec.security_required &= ~(BTM_SEC_OUT_AUTHENTICATE);
+    p_dev_rec->security_required &= ~(BTM_SEC_OUT_AUTHENTICATE);
     l2cu_start_post_bond_timer(p_dev_rec->hci_handle);
     return;
   }
@@ -2658,7 +2650,7 @@ void btm_io_capabilities_req(RawAddress p) {
     /* initiator connecting */
     case BTM_PAIR_STATE_IDLE:
       // TODO: Handle Idle pairing state
-      // security_required = p_dev_rec->sec_rec.security_required;
+      // security_required = p_dev_rec->security_required;
       break;
 
     /* received IO capability response already->acceptor */
@@ -2718,15 +2710,14 @@ void btm_io_capabilities_req(RawAddress p) {
     /* local device initiated the pairing non-bonding -> use
      * required_security_flags_for_pairing */
     if (!(btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
-        (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+        (p_dev_rec->required_security_flags_for_pairing &
          BTM_SEC_OUT_AUTHENTICATE)) {
       if (btm_sec_cb.security_mode == BTM_SEC_MODE_SC) {
         /* SC only mode device requires MITM protection */
         evt_data.auth_req = BTM_AUTH_SP_YES;
       } else {
         evt_data.auth_req =
-            (p_dev_rec->sec_rec.required_security_flags_for_pairing &
-             BTM_SEC_OUT_MITM)
+            (p_dev_rec->required_security_flags_for_pairing & BTM_SEC_OUT_MITM)
                 ? BTM_AUTH_SP_YES
                 : BTM_AUTH_SP_NO;
       }
@@ -2828,8 +2819,8 @@ void btm_io_capabilities_rsp(const tBTM_SP_IO_RSP evt_data) {
   }
 
   /* save the IO capability in the device record */
-  p_dev_rec->sec_rec.rmt_io_caps = evt_data.io_cap;
-  p_dev_rec->sec_rec.rmt_auth_req = evt_data.auth_req;
+  p_dev_rec->rmt_io_caps = evt_data.io_cap;
+  p_dev_rec->rmt_auth_req = evt_data.auth_req;
 
   if (btm_sec_cb.api.p_sp_callback)
     (*btm_sec_cb.api.p_sp_callback)(BTM_SP_IO_RSP_EVT,
@@ -2884,7 +2875,7 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
 
         /* process user confirm req in association with the auth_req param */
         if (btm_sec_cb.devcb.loc_io_caps == BTM_IO_CAP_IO) {
-          if (p_dev_rec->sec_rec.rmt_io_caps == BTM_IO_CAP_UNKNOWN) {
+          if (p_dev_rec->rmt_io_caps == BTM_IO_CAP_UNKNOWN) {
             LOG_ERROR(
                 "did not receive IO cap response prior"
                 " to BTM_SP_CFM_REQ_EVT, failing pairing request");
@@ -2893,10 +2884,10 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
             return;
           }
 
-          if ((p_dev_rec->sec_rec.rmt_io_caps == BTM_IO_CAP_IO ||
-               p_dev_rec->sec_rec.rmt_io_caps == BTM_IO_CAP_OUT) &&
+          if ((p_dev_rec->rmt_io_caps == BTM_IO_CAP_IO ||
+               p_dev_rec->rmt_io_caps == BTM_IO_CAP_OUT) &&
               (btm_sec_cb.devcb.loc_io_caps == BTM_IO_CAP_IO) &&
-              ((p_dev_rec->sec_rec.rmt_auth_req & BTM_AUTH_SP_YES) ||
+              ((p_dev_rec->rmt_auth_req & BTM_AUTH_SP_YES) ||
                (btm_sec_cb.devcb.loc_auth_req & BTM_AUTH_SP_YES))) {
             /* Use Numeric Comparison if
              * 1. Local IO capability is DisplayYesNo,
@@ -2910,13 +2901,13 @@ void btm_proc_sp_req_evt(tBTM_SP_EVT event, const RawAddress bda,
             "btm_proc_sp_req_evt()  just_works:%d, io loc:%d, rmt:%d, auth "
             "loc:%d, rmt:%d",
             evt_data.cfm_req.just_works, btm_sec_cb.devcb.loc_io_caps,
-            p_dev_rec->sec_rec.rmt_io_caps, btm_sec_cb.devcb.loc_auth_req,
-            p_dev_rec->sec_rec.rmt_auth_req);
+            p_dev_rec->rmt_io_caps, btm_sec_cb.devcb.loc_auth_req,
+            p_dev_rec->rmt_auth_req);
 
         evt_data.cfm_req.loc_auth_req = btm_sec_cb.devcb.loc_auth_req;
-        evt_data.cfm_req.rmt_auth_req = p_dev_rec->sec_rec.rmt_auth_req;
+        evt_data.cfm_req.rmt_auth_req = p_dev_rec->rmt_auth_req;
         evt_data.cfm_req.loc_io_caps = btm_sec_cb.devcb.loc_io_caps;
-        evt_data.cfm_req.rmt_io_caps = p_dev_rec->sec_rec.rmt_io_caps;
+        evt_data.cfm_req.rmt_io_caps = p_dev_rec->rmt_io_caps;
         break;
 
       case BTM_SP_KEY_NOTIF_EVT:
@@ -3005,10 +2996,10 @@ void btm_simple_pair_complete(const RawAddress bd_addr, uint8_t status) {
   LOG_VERBOSE(
       "btm_simple_pair_complete()  Pair State: %s  Status:%d  sec_state: %u",
       btm_pair_state_descr(btm_sec_cb.pairing_state), status,
-      p_dev_rec->sec_rec.sec_state);
+      p_dev_rec->sec_state);
 
   if (status == HCI_SUCCESS) {
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_AUTHENTICATED;
+    p_dev_rec->sec_flags |= BTM_SEC_AUTHENTICATED;
   } else if (status == HCI_ERR_PAIRING_NOT_ALLOWED) {
     /* The test spec wants the peer device to get this failure code. */
     btm_sec_change_pairing_state(BTM_PAIR_STATE_WAIT_DISCONNECT);
@@ -3020,7 +3011,7 @@ void btm_simple_pair_complete(const RawAddress bd_addr, uint8_t status) {
     /* stop the timer */
     alarm_cancel(btm_sec_cb.pairing_timer);
 
-    if (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_AUTHENTICATING) {
+    if (p_dev_rec->sec_state != BTM_SEC_STATE_AUTHENTICATING) {
       /* the initiating side: will receive auth complete event. disconnect ACL
        * at that time */
       disc = true;
@@ -3130,11 +3121,11 @@ static void btm_sec_auth_collision(uint16_t handle) {
 
     if (p_dev_rec != NULL) {
       LOG_VERBOSE("btm_sec_auth_collision: state %d (retrying in a moment...)",
-                  p_dev_rec->sec_rec.sec_state);
+                  p_dev_rec->sec_state);
       /* We will restart authentication after timeout */
-      if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING ||
-          p_dev_rec->sec_rec.is_security_state_bredr_encrypting())
-        p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+      if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING ||
+          p_dev_rec->is_security_state_bredr_encrypting())
+        p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
 
       btm_sec_cb.p_collided_dev_rec = p_dev_rec;
       alarm_set_on_mloop(btm_sec_cb.sec_collision_timer, BT_1SEC_TIMEOUT_MS,
@@ -3171,15 +3162,15 @@ static bool btm_sec_auth_retry(uint16_t handle, uint8_t status) {
     btm_sec_cb.collision_start_time = 0;
     btm_restore_mode();
     p_dev_rec->sm4 |= BTM_SM4_RETRY;
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
+    p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
     LOG_VERBOSE("Retry for missing key sm4:x%x sec_flags:0x%x", p_dev_rec->sm4,
-                p_dev_rec->sec_rec.sec_flags);
+                p_dev_rec->sec_flags);
 
     /* With BRCM controller, we do not need to delete the stored link key in
        controller.
        If the stack may sit on top of other controller, we may need this
        BTM_DeleteStoredLinkKey (bd_addr, NULL); */
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
     btm_sec_execute_procedure(p_dev_rec);
     return true;
   }
@@ -3196,10 +3187,10 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
   if (p_dev_rec) {
     LOG_VERBOSE(
         "Security Manager: in state: %s, handle: %d, status: %d, "
-        "dev->sec_rec.sec_state:%d, bda: %s, RName: %s",
+        "dev->sec_state:%d, bda: %s, RName: %s",
         btm_pair_state_descr(btm_sec_cb.pairing_state), handle, status,
-        p_dev_rec->sec_rec.sec_state,
-        ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr), p_dev_rec->sec_bd_name);
+        p_dev_rec->sec_state, ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr),
+        p_dev_rec->sec_bd_name);
   } else {
     LOG_VERBOSE("Security Manager: in state: %s, handle: %d, status: %d",
                 btm_pair_state_descr(btm_sec_cb.pairing_state), handle, status);
@@ -3224,15 +3215,15 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
   */
   if (p_dev_rec && (btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&
       !(btm_sec_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) {
-    p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+    p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
 
     l2cu_start_post_bond_timer(p_dev_rec->hci_handle);
   }
 
   if (!p_dev_rec) return;
 
-  if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+    p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
     was_authenticating = true;
     /* There can be a race condition, when we are starting authentication
      * and the peer device is doing encryption.
@@ -3242,13 +3233,12 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
      * encrypted link, so device is correct.
      */
     if ((status == HCI_ERR_COMMAND_DISALLOWED) &&
-        ((p_dev_rec->sec_rec.sec_flags &
-          (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED)) ==
+        ((p_dev_rec->sec_flags & (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED)) ==
          (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED))) {
       status = HCI_SUCCESS;
     }
     if (status == HCI_SUCCESS) {
-      p_dev_rec->sec_rec.sec_flags |= BTM_SEC_AUTHENTICATED;
+      p_dev_rec->sec_flags |= BTM_SEC_AUTHENTICATED;
     }
   }
 
@@ -3279,7 +3269,7 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
 
   /* If this is a bonding procedure can disconnect the link now */
   if (are_bonding) {
-    p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+    p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
 
     if (status != HCI_SUCCESS) {
       if (((status != HCI_ERR_PEER_USER) &&
@@ -3324,12 +3314,12 @@ void btm_sec_auth_complete(uint16_t handle, tHCI_STATUS status) {
     return;
   }
 
-  if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+  if (p_dev_rec->pin_code_length >= 16 ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
     // If we have MITM protection we have a higher level of security than
     // provided by 16 digits PIN
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+    p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
   }
 
   /* Authentication succeeded, execute the next security procedure, if any */
@@ -3381,23 +3371,22 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
       " request:%s state:%s sec_flags:0x%x",
       hci_status_code_text(status).c_str(),
       (encr_enable) ? "encrypt" : "unencrypt",
-      (p_dev_rec->sec_rec.sec_state) ? "encrypted" : "unencrypted",
-      p_dev_rec->sec_rec.sec_flags);
+      (p_dev_rec->sec_state) ? "encrypted" : "unencrypted",
+      p_dev_rec->sec_flags);
 
   if (status == HCI_SUCCESS) {
     if (encr_enable) {
       if (p_dev_rec->hci_handle == handle) {  // classic
-        p_dev_rec->sec_rec.sec_flags |=
-            (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED);
-        if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-            p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-            p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
-          p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+        p_dev_rec->sec_flags |= (BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED);
+        if (p_dev_rec->pin_code_length >= 16 ||
+            p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+            p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+          p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
         }
       } else if (p_dev_rec->ble_hci_handle == handle) {  // BLE
-        p_dev_rec->sec_rec.set_le_device_encrypted();
-        if (p_dev_rec->sec_rec.is_le_link_key_authenticated()) {
-          p_dev_rec->sec_rec.set_le_device_authenticated();
+        p_dev_rec->set_le_device_encrypted();
+        if (p_dev_rec->is_le_link_key_authenticated()) {
+            p_dev_rec->set_le_device_authenticated();
         }
       } else {
         LOG_ERROR(
@@ -3411,9 +3400,9 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
       /* mark link not to be encrypted, so that when we execute security next
        * time it will kick in again */
       if (p_dev_rec->hci_handle == handle) {  // clasic
-        p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_ENCRYPTED;
+        p_dev_rec->sec_flags &= ~BTM_SEC_ENCRYPTED;
       } else if (p_dev_rec->ble_hci_handle == handle) {  // BLE
-        p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LE_ENCRYPTED;
+        p_dev_rec->sec_flags &= ~BTM_SEC_LE_ENCRYPTED;
       } else {
         LOG_ERROR(
             "Received encryption change for unknown device handle:0x%04x "
@@ -3423,8 +3412,8 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
     }
   }
 
-  const bool is_encrypted = p_dev_rec->sec_rec.is_le_device_encrypted() ||
-                            p_dev_rec->sec_rec.is_device_encrypted();
+  const bool is_encrypted =
+      p_dev_rec->is_le_device_encrypted() || p_dev_rec->is_device_encrypted();
   BTM_LogHistory(
       kBtmLogTag,
       (transport == BT_TRANSPORT_LE) ? p_dev_rec->ble.pseudo_addr
@@ -3435,49 +3424,47 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
                          bt_transport_text(transport).c_str(),
                          is_encrypted ? 'T' : 'F'));
 
-  LOG_DEBUG("after update p_dev_rec->sec_rec.sec_flags=0x%x",
-            p_dev_rec->sec_rec.sec_flags);
+  LOG_DEBUG("after update p_dev_rec->sec_flags=0x%x", p_dev_rec->sec_flags);
 
   btm_sec_check_pending_enc_req(p_dev_rec, transport, encr_enable);
 
   if (transport == BT_TRANSPORT_LE) {
     if (status == HCI_ERR_KEY_MISSING || status == HCI_ERR_AUTH_FAILURE ||
         status == HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE) {
-      p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
-      p_dev_rec->sec_rec.ble_keys.key_type = BTM_LE_KEY_NONE;
+      p_dev_rec->sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN);
+      p_dev_rec->ble_keys.key_type = BTM_LE_KEY_NONE;
     }
-    p_dev_rec->sec_rec.sec_status = status;
+    p_dev_rec->sec_status = status;
     btm_ble_link_encrypted(p_dev_rec->ble.pseudo_addr, encr_enable);
     return;
   } else {
     /* BR/EDR connection, update the encryption key size to be 16 as always */
-    p_dev_rec->sec_rec.enc_key_size = 16;
+    p_dev_rec->enc_key_size = 16;
   }
 
-  LOG_DEBUG("in new_encr_key_256 is %d",
-            p_dev_rec->sec_rec.new_encryption_key_is_p256);
+  LOG_DEBUG("in new_encr_key_256 is %d", p_dev_rec->new_encryption_key_is_p256);
 
   if ((status == HCI_SUCCESS) && encr_enable &&
       (p_dev_rec->hci_handle == handle)) {
     /* if BR key is temporary no need for LE LTK derivation */
     bool derive_ltk = true;
-    if (p_dev_rec->sec_rec.rmt_auth_req == BTM_AUTH_SP_NO &&
+    if (p_dev_rec->rmt_auth_req == BTM_AUTH_SP_NO &&
         btm_sec_cb.devcb.loc_auth_req == BTM_AUTH_SP_NO) {
       derive_ltk = false;
       LOG_VERBOSE("BR key is temporary, skip derivation of LE LTK");
     }
     tHCI_ROLE role = HCI_ROLE_UNKNOWN;
     BTM_GetRole(p_dev_rec->bd_addr, &role);
-    if (p_dev_rec->sec_rec.new_encryption_key_is_p256) {
+    if (p_dev_rec->new_encryption_key_is_p256) {
       if (btm_sec_use_smp_br_chnl(p_dev_rec) && role == HCI_ROLE_CENTRAL &&
           /* if LE key is not known, do deriving */
-          (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) ||
+          (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) ||
            /* or BR key is higher security than existing LE keys */
-           (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
-            (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_AUTHED))) &&
+           (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
+            (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_AUTHED))) &&
           derive_ltk) {
         /* BR/EDR is encrypted with LK that can be used to derive LE LTK */
-        p_dev_rec->sec_rec.new_encryption_key_is_p256 = false;
+        p_dev_rec->new_encryption_key_is_p256 = false;
 
         LOG_VERBOSE("start SM over BR/EDR");
         SMP_BR_PairWith(p_dev_rec->bd_addr);
@@ -3486,17 +3473,17 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
   }
 
   /* If this encryption was started by peer do not need to do anything */
-  if (!p_dev_rec->sec_rec.is_security_state_bredr_encrypting()) {
-    if (BTM_SEC_STATE_DELAY_FOR_ENC == p_dev_rec->sec_rec.sec_state) {
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  if (!p_dev_rec->is_security_state_bredr_encrypting()) {
+    if (BTM_SEC_STATE_DELAY_FOR_ENC == p_dev_rec->sec_state) {
+      p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
       LOG_VERBOSE("clearing callback. p_dev_rec=%p, p_callback=%p", p_dev_rec,
-                  p_dev_rec->sec_rec.p_callback);
-      p_dev_rec->sec_rec.p_callback = NULL;
+                  p_dev_rec->p_callback);
+      p_dev_rec->p_callback = NULL;
       l2cu_resubmit_pending_sec_req(&p_dev_rec->bd_addr);
       return;
     } else if (!concurrentPeerAuthIsEnabled() &&
-               p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
-      p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+               p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+      p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
       return;
     }
     if (!handleUnexpectedEncryptionChange()) {
@@ -3504,7 +3491,7 @@ void btm_sec_encrypt_change(uint16_t handle, tHCI_STATUS status,
     }
   }
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
   /* If encryption setup failed, notify the waiting layer */
   if (status != HCI_SUCCESS) {
     btm_sec_dev_rec_cback_event(p_dev_rec, BTM_ERR_PROCESSING, false);
@@ -3617,7 +3604,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
               "without asking PIN");
 
           p_dev_rec->sm4 &= ~BTM_SM4_CONN_PEND;
-          if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) {
+          if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) {
             /* remote device name is known, start a new acl connection */
 
             /* Start timer with 0 to initiate connection with new LCB */
@@ -3700,11 +3687,10 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
   if (status != HCI_SUCCESS) {
     /* If connection failed because of during pairing, need to tell user */
     if (is_pairing_device) {
-      p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
-      p_dev_rec->sec_rec.sec_flags &=
+      p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+      p_dev_rec->sec_flags &=
           ~((BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED) << bit_shift);
-      LOG_VERBOSE("security_required:%x ",
-                  p_dev_rec->sec_rec.security_required);
+      LOG_VERBOSE("security_required:%x ", p_dev_rec->security_required);
 
       btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
 
@@ -3717,7 +3703,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
          2.  Link key for the remote device is present.
          3.  Remote is SSP capable.
      */
-    else if ((p_dev_rec->sec_rec.link_key_type <= BTM_LKEY_TYPE_REMOTE_UNIT) &&
+    else if ((p_dev_rec->link_key_type <= BTM_LKEY_TYPE_REMOTE_UNIT) &&
              (((status == HCI_ERR_AUTH_FAILURE) ||
                (status == HCI_ERR_KEY_MISSING) ||
                (status == HCI_ERR_HOST_REJECT_SECURITY) ||
@@ -3726,8 +3712,8 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
                (status == HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED) ||
                (status == HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE) ||
                (status == HCI_ERR_REPEATED_ATTEMPTS)))) {
-      p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
-      p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN << bit_shift);
+      p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+      p_dev_rec->sec_flags &= ~(BTM_SEC_LE_LINK_KEY_KNOWN << bit_shift);
 
 #ifdef BRCM_NOT_4_BTE
       /* If we rejected pairing, pass this special result code */
@@ -3768,14 +3754,13 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
    * the authenticate requirement bit.  Reset the pairing state machine
    * and inform l2cap if the directed bonding was initiated.
    */
-  if (is_pairing_device &&
-      (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
-    if (p_dev_rec->sec_rec.link_key_not_sent) {
-      p_dev_rec->sec_rec.link_key_not_sent = false;
+  if (is_pairing_device && (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)) {
+    if (p_dev_rec->link_key_not_sent) {
+      p_dev_rec->link_key_not_sent = false;
       btm_send_link_key_notif(p_dev_rec);
     }
 
-    p_dev_rec->sec_rec.security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
+    p_dev_rec->security_required &= ~BTM_SEC_OUT_AUTHENTICATE;
 
     /* remember flag before it is initialized */
     const bool is_pair_flags_we_started_dd =
@@ -3791,7 +3776,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
     BTM_LogHistory(kBtmLogTag, bda, "Dedicated bonding",
                    base::StringPrintf("Initiated:%c pairing_flag:0x%02x",
                                       (is_pair_flags_we_started_dd) ? 'T' : 'F',
-                                      p_dev_rec->sec_rec.sec_flags));
+                                      p_dev_rec->sec_flags));
   }
 
   p_dev_rec->hci_handle = handle;
@@ -3811,18 +3796,18 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
   /* Initialize security flags.  We need to do that because some            */
   /* authorization complete could have come after the connection is dropped */
   /* and that would set wrong flag that link has been authorized already    */
-  p_dev_rec->sec_rec.sec_flags &=
+  p_dev_rec->sec_flags &=
       ~((BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED | BTM_SEC_ROLE_SWITCHED)
         << bit_shift);
 
   if (enc_mode != HCI_ENCRYPT_MODE_DISABLED)
-    p_dev_rec->sec_rec.sec_flags |=
+    p_dev_rec->sec_flags |=
         ((BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED) << bit_shift);
 
-  if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
-    p_dev_rec->sec_rec.sec_flags |= (BTM_SEC_16_DIGIT_PIN_AUTHED << bit_shift);
+  if (p_dev_rec->pin_code_length >= 16 ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+    p_dev_rec->sec_flags |= (BTM_SEC_16_DIGIT_PIN_AUTHED << bit_shift);
   }
 
   /* After connection is established we perform security if we do not know */
@@ -3830,7 +3815,7 @@ void btm_sec_connected(const RawAddress& bda, uint16_t handle,
   /* been scheduled while connection was down */
   LOG_DEBUG("Is connection locally initiated:%s",
             logbool(p_dev_rec->is_originator).c_str());
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) ||
+  if (!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) ||
       p_dev_rec->is_originator) {
     res = btm_sec_execute_procedure(p_dev_rec);
     if (res != BTM_CMD_STARTED)
@@ -3891,7 +3876,7 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
     LOG_DEBUG("Disconnected while pairing process active handle:0x%04x",
               handle);
     btm_sec_change_pairing_state(BTM_PAIR_STATE_IDLE);
-    p_dev_rec->sec_rec.sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
+    p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_KNOWN;
 
     /* If the disconnection reason is REPEATED_ATTEMPTS,
        send this error message to complete callback function
@@ -3922,8 +3907,7 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
       "Disconnection complete device:%s name:%s state:%s reason:%s sec_req:%x",
       ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr), p_dev_rec->sec_bd_name,
       btm_pair_state_descr(btm_sec_cb.pairing_state),
-      hci_reason_code_text(reason).c_str(),
-      p_dev_rec->sec_rec.security_required);
+      hci_reason_code_text(reason).c_str(), p_dev_rec->security_required);
 
   // TODO Should this be gated by the transport check below ?
   btm_ble_update_mode_operation(HCI_ROLE_UNKNOWN, &p_dev_rec->bd_addr,
@@ -3932,32 +3916,31 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
 
   if (transport == BT_TRANSPORT_LE) {
     p_dev_rec->ble_hci_handle = HCI_INVALID_HANDLE;
-    p_dev_rec->sec_rec.sec_flags &=
-        ~(BTM_SEC_LE_AUTHENTICATED | BTM_SEC_LE_ENCRYPTED |
-          BTM_SEC_ROLE_SWITCHED);
-    p_dev_rec->sec_rec.enc_key_size = 0;
+    p_dev_rec->sec_flags &= ~(BTM_SEC_LE_AUTHENTICATED | BTM_SEC_LE_ENCRYPTED |
+                              BTM_SEC_ROLE_SWITCHED);
+    p_dev_rec->enc_key_size = 0;
     p_dev_rec->suggested_tx_octets = 0;
 
-    if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) == 0) {
-      p_dev_rec->sec_rec.sec_flags &=
+    if ((p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN) == 0) {
+      p_dev_rec->sec_flags &=
           ~(BTM_SEC_LE_LINK_KEY_AUTHED | BTM_SEC_LE_AUTHENTICATED);
     }
   } else {
     p_dev_rec->hci_handle = HCI_INVALID_HANDLE;
-    p_dev_rec->sec_rec.sec_flags &=
+    p_dev_rec->sec_flags &=
         ~(BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED | BTM_SEC_ROLE_SWITCHED |
           BTM_SEC_16_DIGIT_PIN_AUTHED);
 
     // Remove temporary key.
-    if (p_dev_rec->sec_rec.bond_type == BOND_TYPE_TEMPORARY)
-      p_dev_rec->sec_rec.sec_flags &= ~(BTM_SEC_LINK_KEY_KNOWN);
+    if (p_dev_rec->bond_type == BOND_TYPE_TEMPORARY)
+      p_dev_rec->sec_flags &= ~(BTM_SEC_LINK_KEY_KNOWN);
   }
 
   /* Some devices hardcode sample LTK value from spec, instead of generating
    * one. Treat such devices as insecure, and remove such bonds on
    * disconnection.
    */
-  if (is_sample_ltk(p_dev_rec->sec_rec.ble_keys.pltk)) {
+  if (is_sample_ltk(p_dev_rec->ble_keys.pltk)) {
     LOG_INFO("removing bond to device that used sample LTK: %s",
              ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr));
 
@@ -3965,23 +3948,23 @@ void btm_sec_disconnected(uint16_t handle, tHCI_REASON reason,
     return;
   }
 
-  if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH) {
+  if (p_dev_rec->sec_state == BTM_SEC_STATE_DISCONNECTING_BOTH) {
     LOG_DEBUG("Waiting for other transport to disconnect current:%s",
               bt_transport_text(transport).c_str());
-    p_dev_rec->sec_rec.sec_state = (transport == BT_TRANSPORT_LE)
-                                       ? BTM_SEC_STATE_DISCONNECTING
-                                       : BTM_SEC_STATE_DISCONNECTING_BLE;
+    p_dev_rec->sec_state = (transport == BT_TRANSPORT_LE)
+                               ? BTM_SEC_STATE_DISCONNECTING
+                               : BTM_SEC_STATE_DISCONNECTING_BLE;
     return;
   }
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_IDLE;
-  p_dev_rec->sec_rec.security_required = BTM_SEC_NONE;
+  p_dev_rec->sec_state = BTM_SEC_STATE_IDLE;
+  p_dev_rec->security_required = BTM_SEC_NONE;
 
-  if (p_dev_rec->sec_rec.p_callback != nullptr) {
-    tBTM_SEC_CALLBACK* p_callback = p_dev_rec->sec_rec.p_callback;
+  if (p_dev_rec->p_callback != nullptr) {
+    tBTM_SEC_CALLBACK* p_callback = p_dev_rec->p_callback;
     /* when the peer device time out the authentication before
        we do, this call back must be reset here */
-    p_dev_rec->sec_rec.p_callback = nullptr;
-    (*p_callback)(&p_dev_rec->bd_addr, transport, p_dev_rec->sec_rec.p_ref_data,
+    p_dev_rec->p_callback = nullptr;
+    (*p_callback)(&p_dev_rec->bd_addr, transport, p_dev_rec->p_ref_data,
                   BTM_ERR_PROCESSING);
     LOG_DEBUG("Cleaned up pending security state device:%s transport:%s",
               ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr),
@@ -4071,24 +4054,24 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
   btm_restore_mode();
 
   if (key_type != BTM_LKEY_TYPE_CHANGED_COMB)
-    p_dev_rec->sec_rec.link_key_type = key_type;
+    p_dev_rec->link_key_type = key_type;
 
-  p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
+  p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
 
   /*
    * Until this point in time, we do not know if MITM was enabled, hence we
    * add the extended security flag here.
    */
-  if (p_dev_rec->sec_rec.pin_code_length >= 16 ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
-      p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
-    p_dev_rec->sec_rec.sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
+  if (p_dev_rec->pin_code_length >= 16 ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB ||
+      p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256) {
+    p_dev_rec->sec_flags |= BTM_SEC_LINK_KEY_AUTHED;
+    p_dev_rec->sec_flags |= BTM_SEC_16_DIGIT_PIN_AUTHED;
   }
 
   /* BR/EDR connection, update the encryption key size to be 16 as always */
-  p_dev_rec->sec_rec.enc_key_size = 16;
-  p_dev_rec->sec_rec.link_key = link_key;
+  p_dev_rec->enc_key_size = 16;
+  p_dev_rec->link_key = link_key;
 
   if ((btm_sec_cb.pairing_state != BTM_PAIR_STATE_IDLE) &&
       (btm_sec_cb.pairing_bda == p_bda)) {
@@ -4102,17 +4085,17 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
   if (ltk_derived_lk) {
     if (btm_sec_cb.api.p_link_key_callback) {
       LOG_VERBOSE("Save LTK derived LK (key_type = %d)",
-                  p_dev_rec->sec_rec.link_key_type);
+                  p_dev_rec->link_key_type);
       (*btm_sec_cb.api.p_link_key_callback)(
           p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name, link_key,
-          p_dev_rec->sec_rec.link_key_type, true /* is_ctkd */);
+          p_dev_rec->link_key_type, true /* is_ctkd */);
     }
   } else {
-    if ((p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256) ||
-        (p_dev_rec->sec_rec.link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
-      p_dev_rec->sec_rec.new_encryption_key_is_p256 = true;
+    if ((p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB_P_256) ||
+        (p_dev_rec->link_key_type == BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+      p_dev_rec->new_encryption_key_is_p256 = true;
       LOG_VERBOSE("set new_encr_key_256 to %d",
-                  p_dev_rec->sec_rec.new_encryption_key_is_p256);
+                  p_dev_rec->new_encryption_key_is_p256);
     }
   }
 
@@ -4120,14 +4103,14 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
    */
   /* resolved. Unless it is a HID Device and we really need to send all link
    * keys. */
-  if ((!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) &&
+  if ((!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) &&
        ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) !=
         BTM_COD_MAJOR_PERIPHERAL)) &&
       !ltk_derived_lk) {
     LOG_VERBOSE("Delayed BDA: %s, Type: %d", ADDRESS_TO_LOGGABLE_CSTR(p_bda),
                 key_type);
 
-    p_dev_rec->sec_rec.link_key_not_sent = true;
+    p_dev_rec->link_key_not_sent = true;
 
     /* If it is for bonding nothing else will follow, so we need to start name
      * resolution */
@@ -4136,7 +4119,7 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
     }
 
     LOG_VERBOSE("rmt_io_caps:%d, sec_flags:x%x, dev_class[1]:x%02x",
-                p_dev_rec->sec_rec.rmt_io_caps, p_dev_rec->sec_rec.sec_flags,
+                p_dev_rec->rmt_io_caps, p_dev_rec->sec_flags,
                 p_dev_rec->dev_class[1]);
     return;
   }
@@ -4144,7 +4127,7 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
 /* We will save link key only if the user authorized it - BTE report link key in
  * all cases */
 #ifdef BRCM_NONE_BTE
-  if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_AUTHED)
+  if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_AUTHED)
 #endif
   {
     if (btm_sec_cb.api.p_link_key_callback) {
@@ -4152,11 +4135,11 @@ void btm_sec_link_key_notification(const RawAddress& p_bda,
         LOG_VERBOSE(
             "btm_sec_link_key_notification()  LTK derived LK is saved already"
             " (key_type = %d)",
-            p_dev_rec->sec_rec.link_key_type);
+            p_dev_rec->link_key_type);
       } else {
         (*btm_sec_cb.api.p_link_key_callback)(
             p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name, link_key,
-            p_dev_rec->sec_rec.link_key_type, false /* is_ctkd */);
+            p_dev_rec->link_key_type, false /* is_ctkd */);
       }
     }
   }
@@ -4176,7 +4159,7 @@ void btm_sec_link_key_request(const RawAddress bda) {
 
   LOG_VERBOSE("bda: %s", ADDRESS_TO_LOGGABLE_CSTR(bda));
   if (!concurrentPeerAuthIsEnabled()) {
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+    p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
   }
 
   if ((btm_sec_cb.pairing_state == BTM_PAIR_STATE_WAIT_PIN_REQ) &&
@@ -4189,8 +4172,8 @@ void btm_sec_link_key_request(const RawAddress bda) {
     btsnd_hcic_link_key_neg_reply(bda);
     return;
   }
-  if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
-    btsnd_hcic_link_key_req_reply(bda, p_dev_rec->sec_rec.link_key);
+  if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) {
+    btsnd_hcic_link_key_req_reply(bda, p_dev_rec->link_key);
     return;
   }
 
@@ -4426,14 +4409,14 @@ void btm_sec_pin_code_request(const RawAddress p_bda) {
     /* device, so HCI level is flow controlled */
     /* Also cannot send remote name request while paging, i.e. connection is not
      * completed */
-    if (p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) {
+    if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) {
       LOG_VERBOSE("btm_sec_pin_code_request going for callback");
 
       btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
       if (p_cb->api.p_pin_callback) {
         (*p_cb->api.p_pin_callback)(
             p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name,
-            (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+            (p_dev_rec->required_security_flags_for_pairing &
              BTM_SEC_IN_MIN_16_DIGIT_PIN));
       }
     } else {
@@ -4501,21 +4484,20 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
   CHECK(p_dev_rec != nullptr);
   LOG_DEBUG(
       "security_required:0x%x security_flags:0x%x security_state:%s[%hhu]",
-      p_dev_rec->sec_rec.security_required, p_dev_rec->sec_rec.sec_flags,
-      security_state_text(
-          static_cast<tSECURITY_STATE>(p_dev_rec->sec_rec.sec_state))
+      p_dev_rec->security_required, p_dev_rec->sec_flags,
+      security_state_text(static_cast<tSECURITY_STATE>(p_dev_rec->sec_state))
           .c_str(),
-      p_dev_rec->sec_rec.sec_state);
+      p_dev_rec->sec_state);
 
-  if (p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_IDLE &&
-      p_dev_rec->sec_rec.sec_state != BTM_SEC_STATE_LE_ENCRYPTING) {
+  if (p_dev_rec->sec_state != BTM_SEC_STATE_IDLE &&
+      p_dev_rec->sec_state != BTM_SEC_STATE_LE_ENCRYPTING) {
     LOG_INFO("No immediate action taken in busy state: %s",
-             security_state_text(p_dev_rec->sec_rec.sec_state).c_str());
+              security_state_text(p_dev_rec->sec_state).c_str());
     return (BTM_CMD_STARTED);
   }
 
   /* If any security is required, get the name first */
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) &&
+  if (!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) &&
       (p_dev_rec->hci_handle != HCI_INVALID_HANDLE)) {
     LOG_DEBUG("Security Manager: Start get name");
     if (!btm_sec_start_get_name(p_dev_rec)) {
@@ -4531,21 +4513,23 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
     bool start_auth = false;
 
     // Check link status of BR/EDR
-    if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_AUTHENTICATED)) {
+    if (!(p_dev_rec->sec_flags & BTM_SEC_AUTHENTICATED)) {
       if (p_dev_rec->IsLocallyInitiated()) {
-        if (p_dev_rec->sec_rec.security_required & BTM_SEC_OUT_AUTHENTICATE) {
-          LOG_DEBUG("Outgoing authentication Required");
+        if (p_dev_rec->security_required &
+            (BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT)) {
+          LOG_DEBUG("Outgoing authentication/encryption Required");
           start_auth = true;
         }
       } else {
-        if (p_dev_rec->sec_rec.security_required & BTM_SEC_IN_AUTHENTICATE) {
-          LOG_DEBUG("Incoming authentication Required");
+        if (p_dev_rec->security_required &
+            (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT)) {
+          LOG_DEBUG("Incoming authentication/encryption Required");
           start_auth = true;
         }
       }
     }
 
-    if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED)) {
+    if (!(p_dev_rec->sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED)) {
       /*
        * We rely on BTM_SEC_16_DIGIT_PIN_AUTHED being set if MITM is in use,
        * as 16 DIGIT is only needed if MITM is not used. Unfortunately, the
@@ -4553,8 +4537,7 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
        * authenticated connections, hence we cannot distinguish here.
        */
       if (!p_dev_rec->IsLocallyInitiated()) {
-        if (p_dev_rec->sec_rec.security_required &
-            BTM_SEC_IN_MIN_16_DIGIT_PIN) {
+        if (p_dev_rec->security_required & BTM_SEC_IN_MIN_16_DIGIT_PIN) {
           LOG_DEBUG("BTM_SEC_IN_MIN_16_DIGIT_PIN Required");
           start_auth = true;
         }
@@ -4575,12 +4558,11 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
        * or even IOP issues, if a reconnect causes a new connection that
        * requires an upgrade.
        */
-      if ((p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN) &&
-          (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED) &&
-           (!p_dev_rec->IsLocallyInitiated() &&
-            (p_dev_rec->sec_rec.security_required &
-             BTM_SEC_IN_MIN_16_DIGIT_PIN)))) {
-        p_dev_rec->sec_rec.sec_flags &=
+      if ((p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN) &&
+          (!(p_dev_rec->sec_flags & BTM_SEC_16_DIGIT_PIN_AUTHED) &&
+          (!p_dev_rec->IsLocallyInitiated() &&
+            (p_dev_rec->security_required & BTM_SEC_IN_MIN_16_DIGIT_PIN)))) {
+        p_dev_rec->sec_flags &=
             ~(BTM_SEC_LINK_KEY_KNOWN | BTM_SEC_LINK_KEY_AUTHED |
               BTM_SEC_AUTHENTICATED);
       }
@@ -4592,39 +4574,39 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
 
   /* If connection is not encrypted and encryption is required */
   /* start encryption and return PENDING to the caller */
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_ENCRYPTED) &&
+  if (!(p_dev_rec->sec_flags & BTM_SEC_ENCRYPTED) &&
       ((p_dev_rec->IsLocallyInitiated() &&
-        (p_dev_rec->sec_rec.security_required & BTM_SEC_OUT_ENCRYPT)) ||
+        (p_dev_rec->security_required & BTM_SEC_OUT_ENCRYPT)) ||
        (!p_dev_rec->IsLocallyInitiated() &&
-        (p_dev_rec->sec_rec.security_required & BTM_SEC_IN_ENCRYPT))) &&
+        (p_dev_rec->security_required & BTM_SEC_IN_ENCRYPT))) &&
       (p_dev_rec->hci_handle != HCI_INVALID_HANDLE)) {
     LOG_VERBOSE("Security Manager: Start encryption");
 
     btsnd_hcic_set_conn_encrypt(p_dev_rec->hci_handle, true);
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_ENCRYPTING;
+    p_dev_rec->sec_state = BTM_SEC_STATE_ENCRYPTING;
     return (BTM_CMD_STARTED);
   } else {
     LOG_DEBUG("Encryption not required");
   }
 
-  if ((p_dev_rec->sec_rec.security_required & BTM_SEC_MODE4_LEVEL4) &&
-      (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
+  if ((p_dev_rec->security_required & BTM_SEC_MODE4_LEVEL4) &&
+      (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256)) {
     LOG_VERBOSE(
         "Security Manager: SC only service, but link key type is 0x%02x -"
         "security failure",
-        p_dev_rec->sec_rec.link_key_type);
+        p_dev_rec->link_key_type);
     return (BTM_FAILED_ON_SECURITY);
   }
 
-  if (access_secure_service_from_temp_bond(
-          p_dev_rec, p_dev_rec->IsLocallyInitiated(),
-          p_dev_rec->sec_rec.security_required)) {
+  if (access_secure_service_from_temp_bond(p_dev_rec,
+                                           p_dev_rec->IsLocallyInitiated(),
+                                           p_dev_rec->security_required)) {
     LOG_ERROR("Trying to access a secure service from a temp bonding, rejecting");
     return (BTM_FAILED_ON_SECURITY);
   }
 
   /* All required  security procedures already established */
-  p_dev_rec->sec_rec.security_required &=
+  p_dev_rec->security_required &=
       ~(BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_IN_AUTHENTICATE |
         BTM_SEC_OUT_ENCRYPT | BTM_SEC_IN_ENCRYPT);
 
@@ -4645,7 +4627,7 @@ tBTM_STATUS btm_sec_execute_procedure(tBTM_SEC_DEV_REC* p_dev_rec) {
 static bool btm_sec_start_get_name(tBTM_SEC_DEV_REC* p_dev_rec) {
   if (!BTM_IsDeviceUp()) return false;
 
-  p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_GETTING_NAME;
+  p_dev_rec->sec_state = BTM_SEC_STATE_GETTING_NAME;
 
   /* 0 and NULL are as timeout and callback params because they are not used in
    * security get name case */
@@ -4695,16 +4677,15 @@ static void btm_sec_auth_timer_timeout(void* data) {
     LOG_INFO("invalid device or not found");
   } else if (btm_dev_authenticated(p_dev_rec)) {
     LOG_INFO("device is already authenticated");
-    if (p_dev_rec->sec_rec.p_callback) {
-      (*p_dev_rec->sec_rec.p_callback)(&p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR,
-                                       p_dev_rec->sec_rec.p_ref_data,
-                                       BTM_SUCCESS);
+    if (p_dev_rec->p_callback) {
+      (*p_dev_rec->p_callback)(&p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR,
+                               p_dev_rec->p_ref_data, BTM_SUCCESS);
     }
-  } else if (p_dev_rec->sec_rec.sec_state == BTM_SEC_STATE_AUTHENTICATING) {
+  } else if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING) {
     LOG_INFO("device is in the process of authenticating");
   } else {
     LOG_INFO("starting authentication");
-    p_dev_rec->sec_rec.sec_state = BTM_SEC_STATE_AUTHENTICATING;
+    p_dev_rec->sec_state = BTM_SEC_STATE_AUTHENTICATING;
     btsnd_hcic_auth_request(p_dev_rec->hci_handle);
   }
 }
@@ -4745,7 +4726,7 @@ static void btm_send_link_key_notif(tBTM_SEC_DEV_REC* p_dev_rec) {
   if (btm_sec_cb.api.p_link_key_callback)
     (*btm_sec_cb.api.p_link_key_callback)(
         p_dev_rec->bd_addr, p_dev_rec->dev_class, p_dev_rec->sec_bd_name,
-        p_dev_rec->sec_rec.link_key, p_dev_rec->sec_rec.link_key_type, false);
+        p_dev_rec->link_key, p_dev_rec->link_key_type, false);
 }
 
 /*******************************************************************************
@@ -4870,15 +4851,15 @@ void btm_sec_dev_rec_cback_event(tBTM_SEC_DEV_REC* p_dev_rec,
   LOG_DEBUG("transport=%s, btm_status=%s", is_le_transport ? "le" : "classic",
             btm_status_text(btm_status).c_str());
 
-  tBTM_SEC_CALLBACK* p_callback = p_dev_rec->sec_rec.p_callback;
-  p_dev_rec->sec_rec.p_callback = NULL;
+  tBTM_SEC_CALLBACK* p_callback = p_dev_rec->p_callback;
+  p_dev_rec->p_callback = NULL;
   if (p_callback != nullptr) {
     if (is_le_transport) {
       (*p_callback)(&p_dev_rec->ble.pseudo_addr, BT_TRANSPORT_LE,
-                    p_dev_rec->sec_rec.p_ref_data, btm_status);
+                    p_dev_rec->p_ref_data, btm_status);
     } else {
       (*p_callback)(&p_dev_rec->bd_addr, BT_TRANSPORT_BR_EDR,
-                    p_dev_rec->sec_rec.p_ref_data, btm_status);
+                    p_dev_rec->p_ref_data, btm_status);
     }
   }
 
@@ -4959,7 +4940,7 @@ static bool btm_sec_check_prefetch_pin(tBTM_SEC_DEV_REC* p_dev_rec) {
           btm_sec_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
         (btm_sec_cb.api.p_pin_callback)(
             p_dev_rec->bd_addr, p_dev_rec->dev_class, p_dev_rec->sec_bd_name,
-            (p_dev_rec->sec_rec.required_security_flags_for_pairing &
+            (p_dev_rec->required_security_flags_for_pairing &
              BTM_SEC_IN_MIN_16_DIGIT_PIN));
       }
     }
@@ -5022,7 +5003,7 @@ static void btm_sec_check_pending_enc_req(tBTM_SEC_DEV_REC* p_dev_rec,
           p_e->sec_act == BTM_BLE_SEC_ENCRYPT ||
           p_e->sec_act == BTM_BLE_SEC_ENCRYPT_NO_MITM ||
           (p_e->sec_act == BTM_BLE_SEC_ENCRYPT_MITM &&
-           p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_AUTHENTICATED)) {
+           p_dev_rec->sec_flags & BTM_SEC_LE_AUTHENTICATED)) {
         if (p_e->p_callback)
           (*p_e->p_callback)(&p_dev_rec->bd_addr, transport, p_e->p_ref_data,
                              res);
@@ -5065,7 +5046,7 @@ static uint16_t btm_sec_set_serv_level4_flags(uint16_t cur_security,
  ******************************************************************************/
 void btm_sec_clear_ble_keys(tBTM_SEC_DEV_REC* p_dev_rec) {
   LOG_VERBOSE("Clearing BLE Keys");
-  memset(&p_dev_rec->sec_rec.ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
+  memset(&p_dev_rec->ble_keys, 0, sizeof(tBTM_SEC_BLE_KEYS));
 
   btm_ble_resolving_list_remove_dev(p_dev_rec);
 }
@@ -5083,10 +5064,9 @@ bool btm_sec_is_a_bonded_dev(const RawAddress& bda) {
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(bda);
   bool is_bonded = false;
 
-  if (p_dev_rec &&
-      ((p_dev_rec->sec_rec.ble_keys.key_type &&
-        (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) ||
-       (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_KNOWN))) {
+  if (p_dev_rec && ((p_dev_rec->ble_keys.key_type &&
+                     (p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_KNOWN)) ||
+                    (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN))) {
     is_bonded = true;
   }
   LOG_DEBUG("Device record bonded check peer:%s is_bonded:%s",
@@ -5112,10 +5092,10 @@ static bool btm_sec_use_smp_br_chnl(tBTM_SEC_DEV_REC* p_dev_rec) {
   uint32_t ext_feat;
   uint8_t chnl_mask[L2CAP_FIXED_CHNL_ARRAY_SIZE];
 
-  LOG_VERBOSE("link_key_type = 0x%x", p_dev_rec->sec_rec.link_key_type);
+  LOG_VERBOSE("link_key_type = 0x%x", p_dev_rec->link_key_type);
 
-  if ((p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_UNAUTH_COMB_P_256) &&
-      (p_dev_rec->sec_rec.link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256))
+  if ((p_dev_rec->link_key_type != BTM_LKEY_TYPE_UNAUTH_COMB_P_256) &&
+      (p_dev_rec->link_key_type != BTM_LKEY_TYPE_AUTH_COMB_P_256))
     return false;
 
   if (!L2CA_GetPeerFeatures(p_dev_rec->bd_addr, &ext_feat, chnl_mask))
@@ -5148,7 +5128,7 @@ void btm_sec_set_peer_sec_caps(uint16_t hci_handle, bool ssp_supported,
 
   uint8_t req_pend = (p_dev_rec->sm4 & BTM_SM4_REQ_PEND);
 
-  if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_NAME_KNOWN) ||
+  if (!(p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN) ||
       p_dev_rec->is_originator) {
     tBTM_STATUS btm_status = btm_sec_execute_procedure(p_dev_rec);
     if (btm_status != BTM_CMD_STARTED) {
diff --git a/system/stack/btm/security_device_record.h b/system/stack/btm/security_device_record.h
index 20df089a78..1dd770099f 100644
--- a/system/stack/btm/security_device_record.h
+++ b/system/stack/btm/security_device_record.h
@@ -210,7 +210,12 @@ typedef enum : uint8_t {
  * Define structure for Security Device Record.
  * A record exists for each device authenticated with this device
  */
-struct tBTM_SEC_REC {
+struct tBTM_SEC_DEV_REC {
+  /**
+   * fields used for security
+   */
+  tBTM_SEC_CALLBACK* p_callback;
+  void* p_ref_data;
   tSECURITY_STATE sec_state; /* Operating state                    */
 
   tHCI_STATUS sec_status; /* Status in encryption change event  */
@@ -219,30 +224,67 @@ struct tBTM_SEC_REC {
   uint8_t pin_code_length; /* Length of the pin_code used for pairing */
   uint32_t required_security_flags_for_pairing;
   uint16_t security_required; /* Security required for connection   */
-  // security callback and its argument
-  tBTM_SEC_CALLBACK* p_callback;
-  void* p_ref_data;
 
   bool link_key_not_sent; /* link key notification has not been sent waiting for
                              name */
+  bool role_central;      /* true if current mode is central (BLE)    */
+  uint8_t sm4;            /* BTM_SM4_TRUE, if the peer supports SM4 */
   tBTM_IO_CAP rmt_io_caps;    /* IO capability of the peer device */
   tBTM_AUTH_REQ rmt_auth_req; /* the auth_req flag as in the IO caps rsp evt */
+  bool remote_supports_secure_connections;
   bool new_encryption_key_is_p256; /* Set to true when the newly generated LK
                                    ** is generated from P-256.
                                    ** Link encrypted with such LK can be used
-                                   ** for SM over BR/EDR. */
+                                   ** for SM over BR/EDR.
+                                   */
 
   // BREDR Link Key Info
   LinkKey link_key;      /* Device link key                    */
   uint8_t link_key_type; /* Type of key used in pairing        */
   uint8_t enc_key_size;  /* current link encryption key size   */
 
-  // LE Link Key Info
-  tBTM_SEC_BLE_KEYS ble_keys;
+  tBTM_SEC_BLE_KEYS ble_keys; /* LE Link Key Info */
 
   tBTM_BOND_TYPE bond_type; /* bond type */
 
+  /**
+   *  other fields for device management
+   */
+  RawAddress bd_addr; /* BD_ADDR of the device */
+  tBTM_BLE_ADDR_INFO ble;
+  tBTM_BD_NAME sec_bd_name; /* User friendly name of the device. (may be
+                               truncated to save space in dev_rec table) */
+  DEV_CLASS dev_class;      /* DEV_CLASS of the device            */
+  tBT_DEVICE_TYPE device_type;
+
+  uint32_t timestamp; /* Timestamp of the last connection   */
+  uint16_t hci_handle;     /* Handle to BR/EDR ACL connection when exists */
+  uint16_t ble_hci_handle; /* use in DUMO connection */
+
+  uint16_t suggested_tx_octets; /* Recently suggested tx octects for data length
+                                   extension */
+  uint16_t clock_offset;        /* Latest known clock offset          */
+
+  // whether the peer device can read GAP characteristics only visible in
+  // "discoverable" mode
+  bool can_read_discoverable{true};
+
+  bool remote_features_needed; /* set to true if the local device is in */
+  /* "Secure Connections Only" mode and it receives */
+  /* HCI_IO_CAPABILITY_REQUEST_EVT from the peer before */
+  /* it knows peer's support for Secure Connections */
+  bool remote_supports_hci_role_switch = false;
+  bool remote_supports_bredr;
+  bool remote_supports_ble;
+  bool remote_feature_received = false;
+
+  tBTM_LE_CONN_PRAMS conn_params;
+  tREMOTE_VERSION_INFO remote_version_info;
+
+  bool is_originator; /* true if device is originating ACL connection */
+
  public:
+  RawAddress RemoteAddress() const { return bd_addr; }
   bool is_device_authenticated() const {
     return sec_flags & BTM_SEC_AUTHENTICATED;
   }
@@ -354,11 +396,6 @@ struct tBTM_SEC_REC {
   }
 
   uint8_t get_encryption_key_size() const { return enc_key_size; }
-};
-
-class tBTM_SEC_DEV_REC {
- public:
-  RawAddress RemoteAddress() const { return bd_addr; }
 
   /* Data length extension */
   void set_suggested_tx_octect(uint16_t octets) {
@@ -367,6 +404,9 @@ class tBTM_SEC_DEV_REC {
 
   uint16_t get_suggested_tx_octets() const { return suggested_tx_octets; }
   bool IsLocallyInitiated() const { return is_originator; }
+  bool SupportsSecureConnections() const {
+    return remote_supports_secure_connections;
+  }
 
   uint16_t get_br_edr_hci_handle() const { return hci_handle; }
   uint16_t get_ble_hci_handle() const { return ble_hci_handle; }
@@ -383,10 +423,6 @@ class tBTM_SEC_DEV_REC {
     return device_type & BT_DEVICE_TYPE_BLE;
   }
 
-  bool SupportsSecureConnections() const {
-    return remote_supports_secure_connections;
-  }
-
   std::string ToString() const {
     return base::StringPrintf(
         "%s %6s cod:%s remote_info:%-14s sm4:0x%02x SecureConn:%c name:\"%s\"",
@@ -396,45 +432,4 @@ class tBTM_SEC_DEV_REC {
         (remote_supports_secure_connections) ? 'T' : 'F',
         PRIVATE_NAME(sec_bd_name));
   }
-
- public:
-  RawAddress bd_addr; /* BD_ADDR of the device */
-  tBTM_BLE_ADDR_INFO ble;
-  tBTM_BD_NAME sec_bd_name; /* User friendly name of the device. (may be
-                               truncated to save space in dev_rec table) */
-  DEV_CLASS dev_class;      /* DEV_CLASS of the device            */
-  tBT_DEVICE_TYPE device_type;
-
-  uint32_t timestamp;      /* Timestamp of the last connection   */
-  uint16_t hci_handle;     /* Handle to BR/EDR ACL connection when exists */
-  uint16_t ble_hci_handle; /* use in DUMO connection */
-
-  uint16_t suggested_tx_octets; /* Recently suggested tx octects for data length
-                                   extension */
-  uint16_t clock_offset;        /* Latest known clock offset          */
-
-  // whether the peer device can read GAP characteristics only visible in
-  // "discoverable" mode
-  bool can_read_discoverable{true};
-
-  bool remote_features_needed; /* set to true if the local device is in */
-  /* "Secure Connections Only" mode and it receives */
-  /* HCI_IO_CAPABILITY_REQUEST_EVT from the peer before */
-  /* it knows peer's support for Secure Connections */
-  uint8_t sm4; /* BTM_SM4_TRUE, if the peer supports SM4 */
-  bool remote_supports_hci_role_switch = false;
-  bool remote_supports_bredr;
-  bool remote_supports_ble;
-  bool remote_supports_secure_connections;
-  bool remote_feature_received = false;
-
-  tREMOTE_VERSION_INFO remote_version_info;
-
-  bool role_central;  /* true if current mode is central (BLE)    */
-  bool is_originator; /* true if device is originating ACL connection */
-
-  // BLE connection parameters
-  tBTM_LE_CONN_PRAMS conn_params;
-  // security related properties
-  tBTM_SEC_REC sec_rec;
 };
diff --git a/system/stack/gatt/gatt_api.cc b/system/stack/gatt/gatt_api.cc
index bbe6875f62..26954f58b9 100644
--- a/system/stack/gatt/gatt_api.cc
+++ b/system/stack/gatt/gatt_api.cc
@@ -1684,12 +1684,12 @@ void gatt_load_bonded(void) {
     return;
   }
   for (tBTM_SEC_DEV_REC* p_dev_rec : btm_get_sec_dev_rec()) {
-    if (p_dev_rec->sec_rec.is_link_key_known()) {
+    if (p_dev_rec->is_link_key_known()) {
       LOG_VERBOSE("Add bonded BR/EDR transport %s",
                   ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->bd_addr));
       gatt_bonded_check_add_address(p_dev_rec->bd_addr);
     }
-    if (p_dev_rec->sec_rec.is_le_link_key_known()) {
+    if (p_dev_rec->is_le_link_key_known()) {
       LOG_VERBOSE("Add bonded BLE %s",
                   ADDRESS_TO_LOGGABLE_CSTR(p_dev_rec->ble.pseudo_addr));
       gatt_bonded_check_add_address(p_dev_rec->ble.pseudo_addr);
diff --git a/system/stack/smp/smp_act.cc b/system/stack/smp/smp_act.cc
index b9f13c03d8..eae6ea849b 100644
--- a/system/stack/smp/smp_act.cc
+++ b/system/stack/smp/smp_act.cc
@@ -810,7 +810,7 @@ void smp_br_process_pairing_command(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
 
   LOG_VERBOSE("addr:%s", ADDRESS_TO_LOGGABLE_CSTR(p_cb->pairing_bda));
   /* rejecting BR pairing request over non-SC BR link */
-  if (!p_dev_rec->sec_rec.new_encryption_key_is_p256 &&
+  if (!p_dev_rec->new_encryption_key_is_p256 &&
       p_cb->role == HCI_ROLE_PERIPHERAL) {
     tSMP_INT_DATA smp_int_data;
     smp_int_data.status = SMP_XTRANS_DERIVE_NOT_ALLOW;
@@ -852,7 +852,7 @@ void smp_br_process_pairing_command(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
   p_cb->local_r_key = p_cb->peer_r_key;
 
   if (p_cb->role == HCI_ROLE_PERIPHERAL) {
-    p_dev_rec->sec_rec.new_encryption_key_is_p256 = false;
+    p_dev_rec->new_encryption_key_is_p256 = false;
     /* shortcut to skip Security Grant step */
     p_cb->cb_evt = SMP_BR_KEYS_REQ_EVT;
   } else {
@@ -1330,8 +1330,8 @@ void smp_key_distribution(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
     if (smp_get_state() == SMP_STATE_BOND_PENDING) {
       if (p_cb->derive_lk) {
         tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(p_cb->pairing_bda);
-        if (!(p_dev_rec->sec_rec.sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
-            (p_dev_rec->sec_rec.sec_flags & BTM_SEC_LINK_KEY_AUTHED)) {
+        if (!(p_dev_rec->sec_flags & BTM_SEC_LE_LINK_KEY_AUTHED) &&
+            (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_AUTHED)) {
           LOG_VERBOSE(
               "BR key is higher security than existing LE keys, don't "
               "derive LK from LTK");
diff --git a/system/stack/smp/smp_keys.cc b/system/stack/smp/smp_keys.cc
index c03e100c07..ffacca8321 100644
--- a/system/stack/smp/smp_keys.cc
+++ b/system/stack/smp/smp_keys.cc
@@ -1038,8 +1038,8 @@ bool smp_calculate_long_term_key_from_link_key(tSMP_CB* p_cb) {
   }
 
   Octet16 rev_link_key;
-  std::reverse_copy(p_dev_rec->sec_rec.link_key.begin(),
-                    p_dev_rec->sec_rec.link_key.end(), rev_link_key.begin());
+  std::reverse_copy(p_dev_rec->link_key.begin(), p_dev_rec->link_key.end(),
+                    rev_link_key.begin());
   p_cb->ltk = crypto_toolbox::link_key_to_ltk(rev_link_key,
                                               p_cb->key_derivation_h7_used);
 
diff --git a/system/stack/smp/smp_l2c.cc b/system/stack/smp/smp_l2c.cc
index 1fccd76bce..ebab7f4ec3 100644
--- a/system/stack/smp/smp_l2c.cc
+++ b/system/stack/smp/smp_l2c.cc
@@ -241,7 +241,7 @@ static void smp_br_connect_callback(uint16_t channel, const RawAddress& bd_addr,
   tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(p_cb->pairing_bda);
   if ((smp_get_state() == SMP_STATE_BOND_PENDING ||
        smp_get_state() == SMP_STATE_IDLE) &&
-      (p_dev_rec && p_dev_rec->sec_rec.is_link_key_known()) &&
+      (p_dev_rec && p_dev_rec->is_link_key_known()) &&
       alarm_is_scheduled(p_cb->delayed_auth_timer_ent)) {
     /* If we were to not return here, we would reset SMP control block, and
      * delayed_auth_timer_ent would never be executed. Even though we stored all
diff --git a/system/stack/test/btm/stack_btm_sec_test.cc b/system/stack/test/btm/stack_btm_sec_test.cc
index 73631887f7..3ed859bd69 100644
--- a/system/stack/test/btm/stack_btm_sec_test.cc
+++ b/system/stack/test/btm/stack_btm_sec_test.cc
@@ -130,7 +130,7 @@ TEST_F(StackBtmSecWithInitFreeTest, btm_sec_encrypt_change) {
   // Setup device
   tBTM_SEC_DEV_REC* device_record = btm_sec_allocate_dev_rec();
   ASSERT_NE(nullptr, device_record);
-  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_rec.sec_flags);
+  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_flags);
   device_record->bd_addr = bd_addr;
   device_record->hci_handle = classic_handle;
   device_record->ble_hci_handle = ble_handle;
@@ -138,23 +138,21 @@ TEST_F(StackBtmSecWithInitFreeTest, btm_sec_encrypt_change) {
   // With classic device encryption enable
   btm_sec_encrypt_change(classic_handle, HCI_SUCCESS, 0x01);
   ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_AUTHENTICATED | BTM_SEC_ENCRYPTED,
-            device_record->sec_rec.sec_flags);
+            device_record->sec_flags);
 
   // With classic device encryption disable
   btm_sec_encrypt_change(classic_handle, HCI_SUCCESS, 0x00);
-  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_AUTHENTICATED,
-            device_record->sec_rec.sec_flags);
-  device_record->sec_rec.sec_flags = BTM_SEC_IN_USE;
+  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_AUTHENTICATED, device_record->sec_flags);
+  device_record->sec_flags = BTM_SEC_IN_USE;
 
   // With le device encryption enable
   btm_sec_encrypt_change(ble_handle, HCI_SUCCESS, 0x01);
-  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_LE_ENCRYPTED,
-            device_record->sec_rec.sec_flags);
+  ASSERT_EQ(BTM_SEC_IN_USE | BTM_SEC_LE_ENCRYPTED, device_record->sec_flags);
 
   // With le device encryption disable
   btm_sec_encrypt_change(ble_handle, HCI_SUCCESS, 0x00);
-  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_rec.sec_flags);
-  device_record->sec_rec.sec_flags = BTM_SEC_IN_USE;
+  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_flags);
+  device_record->sec_flags = BTM_SEC_IN_USE;
 
   wipe_secrets_and_remove(device_record);
 }
@@ -262,7 +260,7 @@ TEST_F(StackBtmSecWithInitFreeTest, wipe_secrets_and_remove) {
   // Setup device
   tBTM_SEC_DEV_REC* device_record = btm_sec_allocate_dev_rec();
   ASSERT_NE(nullptr, device_record);
-  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_rec.sec_flags);
+  ASSERT_EQ(BTM_SEC_IN_USE, device_record->sec_flags);
   device_record->bd_addr = bd_addr;
   device_record->hci_handle = classic_handle;
   device_record->ble_hci_handle = ble_handle;
diff --git a/system/stack/test/gatt/gatt_api_test.cc b/system/stack/test/gatt/gatt_api_test.cc
index 770c08f589..61faaa239f 100644
--- a/system/stack/test/gatt/gatt_api_test.cc
+++ b/system/stack/test/gatt/gatt_api_test.cc
@@ -31,18 +31,17 @@ static const size_t QUEUE_SIZE_MAX = 10;
 static tBTM_SEC_DEV_REC* make_bonded_ble_device(const RawAddress& bda,
                                                 const RawAddress& rra) {
   tBTM_SEC_DEV_REC* dev = btm_sec_allocate_dev_rec();
-  dev->sec_rec.sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
+  dev->sec_flags |= BTM_SEC_LE_LINK_KEY_KNOWN;
   dev->bd_addr = bda;
   dev->ble.pseudo_addr = rra;
-  dev->sec_rec.ble_keys.key_type =
-      BTM_LE_KEY_PID | BTM_LE_KEY_PENC | BTM_LE_KEY_LENC;
+  dev->ble_keys.key_type = BTM_LE_KEY_PID | BTM_LE_KEY_PENC | BTM_LE_KEY_LENC;
   return dev;
 }
 
 static tBTM_SEC_DEV_REC* make_bonded_dual_device(const RawAddress& bda,
                                                  const RawAddress& rra) {
   tBTM_SEC_DEV_REC* dev = make_bonded_ble_device(bda, rra);
-  dev->sec_rec.sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
+  dev->sec_flags |= BTM_SEC_LINK_KEY_KNOWN;
   return dev;
 }
 
-- 
2.34.1

